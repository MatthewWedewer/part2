C51 COMPILER V9.53.0.0   READ_SECTOR                                                       11/02/2015 13:12:46 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE READ_SECTOR
OBJECT MODULE PLACED IN read_sector.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE read_sector.c OPTIMIZE(8,SPEED) DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          #include "main.h"
   2          #include "port.h"
   3          #include "read_sector.h"
   4          #include "spi.h"
   5          #include "SDcard.h"
   6          #include <stdio.h>
   7          #include "stdio.h"
   8          
   9            
  10          //  uint16_t  BPB_BytesPerSec;
  11          //  uint8_t   BPB_SecPerClus;
  12          //  uint16_t  BPB_RsvdSecCnt;
  13          //  uint8_t   BPB_NumFATs;
  14          //  uint16_t  BPB_RootEntCnt;
  15          //  uint16_t  BPB_TotSec16;
  16          //  uint16_t  BPB_FATSz16;
  17          //  uint32_t  BPB_HiddenSec;
  18          //  uint32_t  BPB_TotSec32;
  19          //  uint32_t  BPB_FATSz32;
  20          //  uint32_t  BPB_Root_Clus;
  21          //  uint32_t  FirstFirstDataSec=()
  22          
  23          
  24          
  25          uint8_t read_sector(uint32_t sector_number, uint16_t sector_size, uint8_t *array_name)
  26          {
  27   1        uint8_t error_flag;
  28   1        ncs=0;
  29   1        send_command(17, sector_number);
  30   1        error_flag = read_block(sector_size, array_name);
  31   1        ncs=1;
  32   1        return error_flag;  
  33   1      }
  34          
  35          //uint32_t read32(uint16_t offset_address, uint8_t *array_name)
  36          //{
  37          //  if (offset_address <512)
  38          //  {
  39          //    uint32_t return_value =0;
  40          //    uint8_t temp, index;
  41          //        for (index = 0; index < 4; index++)
  42          //    {
  43          //    temp =*(array_name + offset_address + ( 3 - index));
  44          //      return_value= return_value << 8;
  45          //      return_value |= temp;
  46          //    }
  47          //    printf("%lu",return_value);
  48          //    return return_value;
  49          //  }
  50          //  else
  51          //    return OFFSET_ERROR;
  52          //}
  53          
  54          //uint16_t read16(uint16_t offset_address, uint8_t *array_name)
  55          //{
C51 COMPILER V9.53.0.0   READ_SECTOR                                                       11/02/2015 13:12:46 PAGE 2   

  56          //  uint16_t return_value =0;
  57          //  uint8_t temp, index;
  58          //  if(offset_address < 512)
  59          //  {
  60          //    for (index = 0; index < 2; index++)
  61          //    {
  62          //      temp =*(array_name + offset_address + ( 1 - index));
  63          //      return_value= return_value << 8;
  64          //      return_value |= temp;
  65          //    }
  66          //    printf("%u",return_value);
  67          //    return return_value;
  68          //  }
  69          //  else
  70          //  {
  71          //    return OFFSET_ERROR;
  72          //  }
  73          //}
  74          
  75          //uint8_t read8(uint16_t offset_address, uint8_t *array_name)
  76          //{
  77          //  uint8_t return_value =0;
  78          //  uint8_t temp;
  79          //  if(offset_address < 512)
  80          //  {
  81          //    temp =*(array_name + offset_address);
  82          //    return_value= return_value << 8;
  83          //    return_value |= temp;
  84          //    printf("%bu",return_value);
  85          //    return return_value;
  86          //  }
  87          //  else
  88          //  {
  89          //    return OFFSET_ERROR;
  90          //  }
  91          //}
  92          
  93          //uint8_t mount_drive(void)
  94          //{
  95          //  uint8_t sector[512];
  96          //  uint8_t error_flag, rootDirSector;
  97          //  uint16_t numofFATSectors;
  98          //  uint32_t bpb_sector, FATSz, totSec, FATtype, countofClusters, FirstDataSec;
  99          //  
 100          //  error_flag = NO_ERRORS;
 101          //  
 102          //  read_sector(0, 512, sector);
 103          //  if(!(read8(0, sector) == 0xEB || read8(0, sector) == 0xE9))
 104          //  {
 105          //    bpb_sector = read32(0x01C6, sector);
 106          //  }
 107          //  else
 108          //  {
 109          //    error_flag = WRONG_RETURN;
 110          //  }
 111          //  if(error_flag == NO_ERRORS)
 112          //  {
 113          //    read_sector(bpb_sector, 512, sector);
 114          //    
 115          //    BPB_BytesPerSec = read16(0x000B, sector);
 116          //    BPB_SecPerClus  =  read8(0x000D, sector);
 117          //    BPB_RsvdSecCnt  = read16(0x000E, sector);
C51 COMPILER V9.53.0.0   READ_SECTOR                                                       11/02/2015 13:12:46 PAGE 3   

 118          //    BPB_NumFATs     =  read8(0x0010, sector);
 119          //    BPB_RootEntCnt  = read16(0x0011, sector);
 120          //    BPB_TotSec16    = read16(0x0013, sector);
 121          //    BPB_FATSz16     = read16(0x0016, sector);
 122          //    BPB_HiddenSec   = read32(0x001C, sector);
 123          //    BPB_TotSec32    = read32(0x0020, sector);
 124          //    BPB_FATSz32     = read32(0x0024, sector);
 125          //    BPB_Root_Clus   = read32(0x002C, sector);
 126          //    
 127          //    
 128          //    rootDirSector = ((BPB_RootEntCnt * 32) + (BPB_BytesPerSec - 1)) / BPB_BytesPerSec;
 129          //    
 130          //    if(BPB_FATSz16 == 0)
 131          //    {
 132          //      FATSz = BPB_FATSz32;
 133          //      printf("%-20s", "FAT size32 is ");
 134          //      printf("%8.8bX", FATSz);
 135          //    }
 136          //    else
 137          //    {
 138          //      FATSz = BPB_FATSz16;
 139          //      error_flag = WRONG_FAT_TYPE;
 140          //    }
 141          //      
 142          //    if(BPB_TotSec16 == 0)
 143          //    {
 144          //      totSec = BPB_TotSec32;
 145          //      printf("%-20s", "TotSec32 is ");
 146          //      printf("%8.8bX", totSec);
 147          //    }
 148          //    else
 149          //    {
 150          //      totSec = BPB_TotSec16;
 151          //      error_flag = WRONG_FAT_TYPE;
 152          //    }
 153          //    numofFATSectors = FATSz * BPB_NumFATs;  // Dont think this is used.
 154          //    printf("%-20s", "numofFATSectors is ");
 155          //    printf("%8.8bX", numofFATSectors);
 156          //    FirstDataSec = totSec - (BPB_RsvdSecCnt + (BPB_NumFATs * FATSz) + rootDirSector);
 157          //    printf("%-20s", "FirstDataSec is ");
 158          //    printf("%8.8bX", FirstDataSec);
 159          //    countofClusters = FirstDataSec / BPB_SecPerClus;
 160          //    printf("%-20s", "countofClusters is ");
 161          //    printf("%8.8bX", countofClusters);
 162          //    if(countofClusters < 4085) 
 163          //    {
 164          //      FATtype = FAT12;
 165          //      error_flag = WRONG_FAT_TYPE;
 166          //    }
 167          //    else if (countofClusters < 65525)
 168          //    { 
 169          //      FATtype = FAT16;
 170          //      error_flag = WRONG_FAT_TYPE;
 171          //    }
 172          //    else 
 173          //    {
 174          //      FATtype = FAT32;
 175          //    }
 176          //    
 177          //    printf("%-12s", "FAT size is ");
 178          //    printf("%2d", FATtype);
 179          //  }
C51 COMPILER V9.53.0.0   READ_SECTOR                                                       11/02/2015 13:12:46 PAGE 4   

 180          //  
 181          //  return error_flag;
 182          //}
 183          //  
 184          
 185          //uint32_t first_sector(uint32_t cluster_num)
 186          //{
 187          //  uint32_t first_sector;
 188          //  uint32_t N = cluster_num;
 189          //  if (cluster_num ==0)
 190          //    {
 191          //    
 192          //    }
 193          //  else
 194          //    first_sector=((N-2)*BPB_SecPerClus)+ FirstFirstDataSec;
 195          //      
 196          //}
 197          
 198          
 199          
 200          
 201          
 202          
 203          
 204          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =     42    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       9
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
