C51 COMPILER V9.54   READ_SECTOR                                                           10/31/2015 13:15:49 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE READ_SECTOR
OBJECT MODULE PLACED IN read_sector.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE read_sector.c OPTIMIZE(8,SPEED) DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          #include "main.h"
   2          #include "port.h"
   3          #include "read_sector.h"
   4          #include "spi.h"
   5          #include "SDcard.h"
   6          #include <stdio.h>
   7          
   8          #define FAT12 12
   9          #define FAT16 16
  10          #define FAT32 32
  11          #pragma large
*** ERROR C252 IN LINE 11 OF read_sector.c: misplaced primary control, line ignored
  12          
  13          
  14          uint8_t BPB_SecPerClus, BPB_NumFATs;
  15          uint16_t BPB_BytesPerSec, BPB_RsvdSecCnt, BPB_RootEntCnt, BPB_TotSec16, BPB_FATSz16;
  16          uint32_t BPB_HiddenSec, BPB_TotSec32, BPB_FATSz32, BPB_Root_Clus;
  17          
  18          
  19          uint8_t read_sector(uint32_t sector_number, uint16_t sector_size, uint8_t *array_name)
  20          {
  21   1        uint8_t error_flag;
  22   1        ncs=0;
  23   1        error_flag = send_command(17, sector_number);
  24   1        if(error_flag == NO_ERRORS)
  25   1        {
  26   2          read_block(sector_size, array_name);
  27   2        }
  28   1        ncs=1;
  29   1        return error_flag;
  30   1      }
  31          
  32          uint32_t read32(uint16_t offset_address, uint8_t *array_name)
  33          {
  34   1        uint32_t return_value =0;
  35   1        uint8_t temp, index;
  36   1            for (index = 0; index < 4; index++)
  37   1        {
  38   2        temp =*(array_name + offset_address + ( 3 - index));
  39   2          return_value= return_value << 8;
  40   2          return_value |= temp;
  41   2        }
  42   1        return return_value;
  43   1      }
  44          
  45          uint16_t read16(uint16_t offset_address, uint8_t *array_name)
  46          {
  47   1        uint16_t return_value =0;
  48   1        uint8_t temp, index;
  49   1            for (index = 0; index < 4; index++)
  50   1        {
  51   2        temp =*(array_name + offset_address + ( 3 - index));
  52   2            return_value= return_value << 8;
  53   2          return_value |= temp;
  54   2        }
C51 COMPILER V9.54   READ_SECTOR                                                           10/31/2015 13:15:49 PAGE 2   

  55   1        return return_value;
  56   1      }
  57          
  58          uint8_t read8(uint16_t offset_address, uint8_t *array_name)
  59          {
  60   1      uint8_t return_value =0;
  61   1        uint8_t temp, index;
  62   1            for (index = 0; index < 4; index++)
  63   1        {
  64   2        temp =*(array_name + offset_address + ( 3 - index));
  65   2            return_value= return_value << 8;
  66   2          return_value |= temp;
  67   2        }
  68   1        return return_value;
  69   1      }
  70          
  71          uint8_t mount_drive()
  72          {
  73   1        uint8_t sector[512];
  74   1        uint8_t error_flag, FATtype, rootDirSector;
  75   1        uint32_t bpb_sector, FATSz, totSec, dataSec, countofClusters, numofFATSectors;
  76   1        
  77   1        error_flag = NO_ERRORS;
  78   1        
  79   1        read_sector(0, 512, sector);
  80   1        if(!(read8(0, sector) == 0xEB || read8(0,sector) == 0xE9))
  81   1        {
  82   2          bpb_sector = read32(0x01C6, sector);
  83   2        }
  84   1        else
  85   1        {
  86   2          error_flag = WRONG_RETURN;
  87   2        }
  88   1        if(error_flag == NO_ERRORS)
  89   1        {
  90   2          read_sector(bpb_sector, 512, sector);
  91   2          
  92   2          BPB_BytesPerSec = read16(0x000B, sector);
  93   2          BPB_SecPerClus  =  read8(0x000D, sector);
  94   2          BPB_RsvdSecCnt  = read16(0x000E, sector);
  95   2          BPB_NumFATs     =  read8(0x0010, sector);
  96   2          BPB_RootEntCnt  = read16(0x0011, sector);
  97   2          BPB_TotSec16    = read16(0x0013, sector);
  98   2          BPB_FATSz16     = read16(0x0016, sector);
  99   2          BPB_HiddenSec   = read32(0x001C, sector);
 100   2          BPB_TotSec32    = read32(0x0020, sector);
 101   2          BPB_FATSz32     = read32(0x0024, sector);
 102   2          BPB_Root_Clus   = read32(0x002C, sector);
 103   2          
 104   2          
 105   2          
 106   2          rootDirSector = ((BPB_RootEntCnt * 32) + (BPB_BytesPerSec - 1)) / BPB_BytesPerSec;
 107   2          
 108   2          if(BPB_FATSz16 == 0)
 109   2          {
 110   3            FATSz = BPB_FATSz32;
 111   3            printf("%-20s", "FAT size32 is ");
 112   3            printf("%8.8bX", FATSz);
 113   3          }
 114   2          else
 115   2          {
 116   3            FATSz = BPB_FATSz16;
C51 COMPILER V9.54   READ_SECTOR                                                           10/31/2015 13:15:49 PAGE 3   

 117   3            error_flag = WRONG_FAT_TYPE;
 118   3          }
 119   2            
 120   2          if(BPB_TotSec16 == 0)
 121   2          {
 122   3            totSec = BPB_TotSec32;
 123   3            printf("%-20s", "TotSec32 is ");
 124   3            printf("%8.8bX", totSec);
 125   3          }
 126   2          else
 127   2          {
 128   3            totSec = BPB_TotSec16;
 129   3            error_flag = WRONG_FAT_TYPE;
 130   3          }
 131   2          numofFATSectors = FATSz * BPB_NumFATs;  // Dont think this is used.
 132   2          printf("%-20s", "numofFATSectors is ");
 133   2          printf("%8.8bX", numofFATSectors);
 134   2          dataSec = totSec - (BPB_RsvdSecCnt + (BPB_NumFATs * FATSz) + rootDirSector);
 135   2          printf("%-20s", "dataSec is ");
 136   2          printf("%8.8bX", dataSec);
 137   2          countofClusters = dataSec / BPB_SecPerClus;
 138   2          printf("%-20s", "countofClusters is ");
 139   2          printf("%8.8bX", countofClusters);
 140   2          if(countofClusters < 4085) 
 141   2          {
 142   3            FATtype = FAT12;
 143   3            error_flag = WRONG_FAT_TYPE;
 144   3          }
 145   2          else if (countofClusters < 65525)
 146   2          { 
 147   3            FATtype = FAT16;
 148   3            error_flag = WRONG_FAT_TYPE;
 149   3          }
 150   2          else 
 151   2          {
 152   3            FATtype = FAT32;
 153   3          }
 154   2          
 155   2          printf("%-12s", "FAT size is ");
 156   2          printf("%2d", FATtype);
 157   2        }
 158   1        
 159   1        return error_flag;
 160   1      }
 161            
 162          
 163          
 164          
 165          
 166          
 167          
 168          
 169          
 170          
 171          
 172          
 173          
 174          
 175          
 176          
 177          
 178          
C51 COMPILER V9.54   READ_SECTOR                                                           10/31/2015 13:15:49 PAGE 4   

 179          

C51 COMPILATION COMPLETE.  0 WARNING(S),  1 ERROR(S)
