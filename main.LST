C51 COMPILER V9.53.0.0   MAIN                                                              12/15/2015 12:35:43 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          #include "main.h"
   2          #include "port.h"
   3          #include <stdio.h>
   4          #include "uart.h"
   5          #include "print_bytes.h"
   6          #include "hardware_delay.h"
   7          #include "lcd.h"
   8          #include "spi.h"
   9          #include "SDcard.h"
  10          #include "Long_Serial_In.h"
  11          #include "Directory_Functions.h"
  12          #include "i2c.h"
  13          #include "sta013.h"
  14          
  15          
  16          
  17          
  18            
  19          extern uint16_t idata BPB_BytesPerSec;
  20          extern uint8_t code CONFIG, CONFIG2;
  21          extern uint32_t idata FirstRootDirSec;
  22          
  23          uint8_t idata temp8;
  24          uint32_t idata state_g, sector_offset, cluster_g, play_status;
  25          
  26          uint16_t idata index1_g, index2_g;
  27          uint32_t idata sector_base_g, return_entry, next_entry, block_number, sector;
  28          
  29          uint8_t xdata buff1[512];
  30          uint8_t xdata buff2[512];
  31          
  32          
  33          
  34          
  35          
  36          void timer2_ISR(void) interrupt 5
  37          { 
  38   1      
  39   1      //  TF2 = 0;
  40   1      //  TR0 = 0;
  41   1      //  TH0 = TIMER0H;
  42   1      //  TL0 = TIMER0L;
  43   1      //  TF0 = 0;
  44   1      //  TR0 = 1;
  45   1        
  46   1        
  47   1        if(state_g == LOAD_BUFFER_1)
  48   1        {
  49   2          if(sector_offset >= 64)
  50   2          {
  51   3            state_g = FIND_CLUSTER_1;
  52   3          }
  53   2        }
  54   1      
  55   1        if(state_g == LOAD_BUFFER_2)
C51 COMPILER V9.53.0.0   MAIN                                                              12/15/2015 12:35:43 PAGE 2   

  56   1        {
  57   2          if(sector_offset >= 64)
  58   2          {
  59   3            state_g = FIND_CLUSTER_2;
  60   3          }
  61   2        }
  62   1      
  63   1      
  64   1        switch(state_g)
  65   1        {
  66   2          // Data Send 1
  67   2          case DATA_SEND_1:
  68   2          {
  69   3            LED1 = 0;
  70   3            LED2 = 1;
  71   3            LED3 = 1;
  72   3            LED4 = 1;
  73   3            spi_en = 1;
  74   3            trig = 0;
  75   3            while((DATA_REQ == ACTIVE) && (TF0 == 0))                 
  76   3            {
  77   4              SPI_transfer_ISR(buff1[index1_g], & temp8);               // What is temp8
  78   4              index1_g++;                                               // Loosing last bit?
  79   4              if(index1_g > 511) // Buffer 1 empty
  80   4              {
  81   5                if(index2_g >511)
  82   5                {
  83   6                  if(play_status == 3)                                  
  84   6                  {
  85   7                    play_status = 0;
  86   7                  }
  87   6                  else
  88   6                  {
  89   7                    state_g = LOAD_BUFFER_2; // Buff 2 and Buff 1 empty
  90   7                  }
  91   6                }                                                       
  92   5                else
  93   5                {
  94   6                  state_g = DATA_SEND_2; // BUFF 1 empty                //Seems like this is when buffer 1 still has stuff
  95   6                }
  96   5                TF0 = 1;
  97   5              }       // What does this do? is this the interupt for the whole system to keep pace
  98   4            }
  99   3            if((DATA_REQ == INACTIVE) && (state_g == DATA_SEND_1))
 100   3            {
 101   4              printf("INACTIVE 1\n\r");
 102   4              if(index2_g > 511) // Buffer 2 is empty
 103   4              {
 104   5                state_g = LOAD_BUFFER_2; // DR inactive and BUFF 2 empty
 105   5              }
 106   4              else
 107   4              {
 108   5                state_g = DATA_IDLE_1; // DR interupt
 109   5              }
 110   4            }
 111   3            if(DATA_REQ == INACTIVE)
 112   3            {
 113   4              printf("INACTIVE 2\n\r");
 114   4            }
 115   3            spi_en = 0;
 116   3            break;
 117   3          }
C51 COMPILER V9.53.0.0   MAIN                                                              12/15/2015 12:35:43 PAGE 3   

 118   2          
 119   2          //Load Buffer 1
 120   2          case LOAD_BUFFER_1:
 121   2          {
 122   3            LED1 = 1;
 123   3            LED2 = 1;
 124   3            LED3 = 1;
 125   3            LED4 = 1;
 126   3            //printf("LOAD_BUFFER_1\n\r");
 127   3            sector = sector_base_g + sector_offset;
 128   3            read_sector_ISR(sector, buff1);
 129   3            //printf("%8.8lX", sector);
 130   3            sector_offset++;
 131   3            state_g = DATA_IDLE_2;
 132   3            index1_g = 0;
 133   3            
 134   3            break;
 135   3          }
 136   2          
 137   2          // Find Cluster 1
 138   2          case FIND_CLUSTER_1:
 139   2          {
 140   3            LED1 = 1;
 141   3            LED2 = 0;
 142   3            LED3 = 1;
 143   3            LED4 = 1;
 144   3            //printf("FIND_CLUSTER_1\n\r");
 145   3            cluster_g = find_next_cluster_ISR(cluster_g, buff1);
 146   3            if(cluster_g == 0x0FFFFFFF) // Last cluster
 147   3            {
 148   4              printf("DONE\n\r");
 149   4              play_status = 3;
 150   4              state_g = DATA_IDLE_2;
 151   4            }
 152   3            else
 153   3            {
 154   4              sector_base_g = first_sector_ISR(cluster_g);
 155   4              sector_offset = 0;
 156   4              state_g = DATA_IDLE_2;
 157   4            }
 158   3            break;
 159   3          }
 160   2          
 161   2          case DATA_IDLE_1:
 162   2          {
 163   3            LED1 = 1;
 164   3        LED2 = 1;
 165   3        LED3 = 1;
 166   3        LED4 = 1;
 167   3            //printf("DATA_IDLE_1\n\r");
 168   3            if(DATA_REQ == ACTIVE)
 169   3            {
 170   4              state_g = DATA_SEND_1;
 171   4            }
 172   3            break;
 173   3          }
 174   2              
 175   2          // Data Send 2
 176   2          case DATA_SEND_2:
 177   2          {
 178   3            LED1 = 1;
 179   3            LED2 = 1;
C51 COMPILER V9.53.0.0   MAIN                                                              12/15/2015 12:35:43 PAGE 4   

 180   3            LED3 = 0;
 181   3            LED4 = 1;
 182   3            //printf("DATA_SEND_2\n\r");
 183   3            spi_en = 1;
 184   3            while((DATA_REQ == ACTIVE) && (TF0 == 0))                 // Can DATA_REQ go inactive while in the loop
 185   3            {
 186   4              SPI_transfer_ISR(buff1[index2_g], & temp8);               // What is temp8
 187   4              index2_g++;
 188   4              if(index2_g > 511) // Buffer 2 empty
 189   4              {
 190   5                if(index1_g > 511) // Buffer 1 empty
 191   5                {
 192   6                  if(play_status == 3)                                  // Works only if after FIND_CLUSTER. why?
 193   6                  {
 194   7                    play_status = 0;
 195   7                  }
 196   6                  else
 197   6                  {
 198   7                    state_g = LOAD_BUFFER_1; // Buff 1 and Buff 2 empty
 199   7                  }
 200   6                }                                                       // No FIND_CLUSTER
 201   5                else
 202   5                {
 203   6                  state_g = DATA_SEND_1; // BUFF 2 empty                //Seems like this is when buffer 2 still has stuff
 204   6                }
 205   5                TF0 = 1;                                                // What does this do? is this the interupt for the whole system to ke
             -ep pace
 206   5              }
 207   4            }
 208   3            if((DATA_REQ == INACTIVE) && (state_g == DATA_SEND_2))
 209   3            {
 210   4              printf("INACTIVE 2\n\r");
 211   4              if(index1_g > 511) // Buffer 1 is empty
 212   4              {
 213   5                state_g = LOAD_BUFFER_1; // DR inactive and BUFF 1 empty
 214   5              }
 215   4              else
 216   4              {
 217   5                state_g = DATA_IDLE_2; // DR interupt
 218   5              }
 219   4            }
 220   3            if(DATA_REQ == INACTIVE)
 221   3            {
 222   4              printf("INACTIVE 2\n\r");
 223   4            }
 224   3            
 225   3            spi_en = 0;
 226   3            break;
 227   3          }
 228   2          
 229   2          //Load Buffer 2
 230   2          case LOAD_BUFFER_2:
 231   2          {
 232   3            LED1 = 1;
 233   3        LED2 = 1;
 234   3        LED3 = 1;
 235   3        LED4 = 1;
 236   3            //printf("LOAD_BUFFER_2\n\r");
 237   3            sector = sector_base_g + sector_offset;
 238   3            read_sector_ISR(sector, buff2);
 239   3            sector_offset++;
 240   3            state_g = DATA_IDLE_1;
C51 COMPILER V9.53.0.0   MAIN                                                              12/15/2015 12:35:43 PAGE 5   

 241   3            index2_g = 0;
 242   3            break;
 243   3          }
 244   2          
 245   2          // Find Cluster 2
 246   2          case FIND_CLUSTER_2:
 247   2          {
 248   3            LED1 = 1;
 249   3        LED2 = 1;
 250   3        LED3 = 1;
 251   3        LED4 = 0;
 252   3            //printf("FIND_CLUSTER_2\n\r");
 253   3            cluster_g = find_next_cluster_ISR(cluster_g, buff2);
 254   3            if(cluster_g == 0x0FFFFFFF)
 255   3            {
 256   4              play_status = 3;
 257   4              state_g = DATA_IDLE_1;
 258   4            }
 259   3            else
 260   3            {
 261   4              sector_base_g = first_sector_ISR(cluster_g);
 262   4              sector_offset = 0;
 263   4              state_g = DATA_IDLE_1;
 264   4            }
 265   3            break;
 266   3          }
 267   2          
 268   2          case DATA_IDLE_2:
 269   2          {
 270   3            LED1 = 1;
 271   3        LED2 = 1;
 272   3        LED3 = 1;
 273   3        LED4 = 1;
 274   3            //printf("DATA_IDLE_2\n\r");
 275   3            if(DATA_REQ == ACTIVE)
 276   3            {
 277   4              state_g = DATA_SEND_2;
 278   4            }
 279   3            break;
 280   3          }           
 281   2        }
 282   1        trig = 1;
 283   1        TF2 = 0;
 284   1      }
 285          
 286          
 287          
 288          
 289          
 290          
 291          
 292          
 293          void main(void)
 294          {
 295   1        uint8_t error_flag, array_name[2];
 296   1        
 297   1        
 298   1        uint16_t number_of_entries;
 299   1        
 300   1        CKCON0 = 0x01;
 301   1      
 302   1        trig = 1;
C51 COMPILER V9.53.0.0   MAIN                                                              12/15/2015 12:35:43 PAGE 6   

 303   1        LED1=0;
 304   1        UART_Init();
 305   1        LCD_Init();
 306   1        SPI_master_init(400000); // Set clock rate to that speed in Hz
 307   1        error_flag = SDcard_init();
 308   1        
 309   1        printf("%-20s", "Mounting Drive");
 310   1        putchar(10);
 311   1        putchar(13);
 312   1        error_flag = mount_drive(buff1);
 313   1        
 314   1        LCD_Clear();
 315   1        LCD_Write(COMMAND, LINE1);
 316   1        LCD_Print(9,"init done");
 317   1        
 318   1        LED2=0;
 319   1        error_flag = config_file();
 320   1        if (error_flag != NO_ERRORS)
 321   1        {
 322   2          LED4=0;
 323   2          printf("%-10s", "config err ");
 324   2          printf("%2.2bX", error_flag);
 325   2          putchar(10);
 326   2          putchar(13);
 327   2        }
 328   1      
 329   1        array_name[0] = 0x01;
 330   1        array_name[1] = 0xAC;
 331   1        error_flag = test_I2C(array_name);
 332   1        if (error_flag != NO_ERRORS)
 333   1        {
 334   2          LED4=0;
 335   2          printf("%-10s", "ERROR1! ");
 336   2          printf("%2.2bX", error_flag);
 337   2          putchar(10);
 338   2          putchar(13);
 339   2        }
 340   1      
 341   1      
 342   1        SPI_master_init(15000000); // Set clock rate to that speed in Hz
 343   1          
 344   1      
 345   1        LED3=0;
 346   1        
 347   1      
 348   1        if (error_flag != NO_ERRORS)
 349   1        {
 350   2          LED4=0;
 351   2          printf("%-10s", "test_i2c err ");
 352   2          printf("%2.2bX", error_flag);
 353   2          putchar(10);
 354   2          putchar(13);
 355   2        }
 356   1         
 357   1        TH2 = TIMER2H;
 358   1        RCAP2H = TIMER2H; // auto reload TH2
 359   1        TL2 = TIMER2L;
 360   1        RCAP2L = TIMER2L; // auto reload TL2
 361   1        TF0 = 0;
 362   1        T2CON = 0x04;  // 16 bit auto reload mode (CP must be zero) and starts timer 2
 363   1        TR2 = 0;
 364   1        //TH0 = TIMER0H;
C51 COMPILER V9.53.0.0   MAIN                                                              12/15/2015 12:35:43 PAGE 7   

 365   1        //TL0 = TIMER0L;
 366   1          
 367   1        //TMOD |= 0x01;
 368   1        
 369   1        ET2 = 1;                      /* Enable Timer 2 Interrupts */
 370   1        EA = 1;                       /* Global Interrupt Enable */
 371   1      
 372   1      
 373   1      
 374   1      
 375   1      
 376   1      
 377   1      
 378   1      
 379   1        CKCON0 = 0x01;
 380   1      
 381   1      number_of_entries = Print_Directory(FirstRootDirSec, buff1);
 382   1      
 383   1      /************************
 384   1      **        Loop         **
 385   1      ************************/
 386   1      
 387   1        
 388   1        while(1)
 389   1        { 
 390   2          sector_base_g = FirstRootDirSec;
 391   2          while(error_flag == NO_ERRORS)
 392   2          {
 393   3            do
 394   3            {
 395   4              printf("%-35s", "Enter a Block Number: ");
 396   4              block_number = long_serial_input();
 397   4              if(block_number > number_of_entries || block_number == 0)
 398   4              {
 399   5                printf("%-35s", "Number too large.\n\r");
 400   5              }
 401   4            }while(block_number > number_of_entries || block_number == 0);
 402   3            return_entry = Read_Dir_Entry(sector_base_g, block_number, buff1);
 403   3            printf("%-20s", "return_entry");
 404   3            printf("%8.8lX", return_entry);
 405   3            putchar(10);
 406   3            putchar(13);
 407   3            next_entry = return_entry & 0x0FFFFFFF;
 408   3            if(return_entry & 0x10000000)
 409   3            {     
 410   4              printf("%-20s", "was a directory");
 411   4              putchar(10);
 412   4              putchar(13);
 413   4              sector_base_g = first_sector(next_entry);
 414   4              printf("%-20s", "sector_base_g");
 415   4              printf("%8.8lX", sector_base_g);
 416   4              putchar(10);
 417   4              putchar(13);
 418   4              number_of_entries = Print_Directory(sector_base_g, buff1);
 419   4            }
 420   3            if((return_entry & 0x10000000) == 0 && block_number !=0)
 421   3            {
 422   4              sector_offset = 0;
 423   4              printf("%-20s", "was a file");
 424   4              //Open_File(next_entry, buff1);
 425   4              sector_base_g = first_sector(next_entry);
 426   4              sector = sector_base_g + sector_offset;
C51 COMPILER V9.53.0.0   MAIN                                                              12/15/2015 12:35:43 PAGE 8   

 427   4              read_sector(sector, buff1);
 428   4              sector_offset++;
 429   4              sector = sector_base_g + sector_offset;
 430   4              read_sector(sector, buff2);
 431   4              sector_offset++;
 432   4              state_g = DATA_SEND_1;
 433   4      
 434   4      
 435   4              
 436   4              play_status = 1; // Run
 437   4              index1_g = 0;
 438   4              index2_g = 0;
 439   4              TF2 = 0;
 440   4              TR2 = 1;
 441   4              while(play_status != 0)
 442   4              { 
 443   5                
 444   5                //PCON = 1; // Idle mode???
 445   5                
 446   5              }
 447   4              TR2 = 0;
 448   4              
 449   4              number_of_entries = Print_Directory(FirstRootDirSec, buff1); //need to reload the old buff
 450   4            }
 451   3            if(return_entry & 0x80000000)
 452   3            {
 453   4              error_flag = PRINT_ERROR;
 454   4            }
 455   3          }
 456   2          if(error_flag!= NO_ERRORS)
 457   2          {
 458   3            LED4 = 0;
 459   3            putchar(10);
 460   3            putchar(13);
 461   3            printf("%-10s", "ERROR! ");
 462   3            printf("%2.2bX", error_flag);
 463   3            putchar(10);
 464   3            putchar(13);
 465   3            while(1);
 466   3          }
 467   2        }
 468   1      }
 469              
 470              
 471              
 472              
 473              
 474          
 475          
 476          
 477          
 478          
 479              
 480              
 481              
 482              
 483              
 484          //    
 485          //    
 486          //    if(state_g == LOAD_BUFFER_1)
 487          //    {
 488          //      if(sector_offset >= 64)
C51 COMPILER V9.53.0.0   MAIN                                                              12/15/2015 12:35:43 PAGE 9   

 489          //      {
 490          //        state_g = FIND_CLUSTER_1;
 491          //      }
 492          //    }
 493          
 494          //    if(state_g == LOAD_BUFFER_2)
 495          //    {
 496          //      if(sector_offset >= 64)
 497          //      {
 498          //        state_g = FIND_CLUSTER_2;
 499          //      }
 500          //    }
 501          
 502          
 503          //    switch(state_g)
 504          //    {
 505          //      // Data Send 1
 506          //      case DATA_SEND_1:
 507          //      {
 508          //        spi_en = 1;
 509          //        while((DATA_REQ == ACTIVE) && (TF0 == 0))                 // Can DATA_REQ go inactive while in the loop
 510          //        {
 511          //          SPI_transfer_ISR(buff1[index1_g], & temp8);               // What is temp8
 512          //          index1_g++;
 513          //          if(index1_g > 511) // Buffer 1 empty
 514          //          {
 515          //            if(play_status == 3)                                  // Works only if after FIND_CLUSTER. why?
 516          //            {
 517          //              play_status = 0;
 518          //              // state_g = DATA_SEND_2;                           // I think this is where it goes
 519          //            }
 520          //            else
 521          //            {
 522          //              state_g = LOAD_BUFFER_2; // Buff 2 and Buff 1 empty
 523          //            }
 524          //          }                                                       // No FIND_CLUSTER
 525          //          else
 526          //          {
 527          //            state_g = DATA_SEND_2; // BUFF 1 empty                //Seems like this is when buffer 1 still has stuff
 528          //          }
 529          //          TF0 = 1;                                                // What does this do? is this the interupt for the whole system to 
             -keep pace
 530          //        }
 531          //        if((DATA_REQ == INACTIVE) && (state_g == DATA_SEND_1))
 532          //        {
 533          //          if(index2_g > 511) // Buffer 2 is empty
 534          //          {
 535          //            state_g = LOAD_BUFFER_2; // DR inactive and BUFF 2 empty
 536          //          }
 537          //          else
 538          //          {
 539          //            state_g = DATA_IDLE_1; // DR interupt
 540          //          }
 541          //        }
 542          //        spi_en = 0;
 543          //        break;
 544          //      }
 545          //      
 546          //      //Load Buffer 1
 547          //      case LOAD_BUFFER_1:
 548          //      {
 549          //        sector = sector_base_g + sector_offset;
C51 COMPILER V9.53.0.0   MAIN                                                              12/15/2015 12:35:43 PAGE 10  

 550          //        read_sector_ISR(sector, buff1);
 551          //        sector_offset++;
 552          //        state_g = DATA_IDLE_2;
 553          //        break;
 554          //      }
 555          //      
 556          //      // Find Cluster 1
 557          //      case FIND_CLUSTER_1:
 558          //      {
 559          //        cluster_g = find_next_cluster_ISR(cluster_g, buff1);
 560          //        if(cluster_g == 0x0FFFFFFF)
 561          //        {
 562          //          play_status = 3;
 563          //          state_g = DATA_IDLE_2;
 564          //        }
 565          //        else
 566          //        {
 567          //          sector_base_g = first_sector_ISR(cluster_g);
 568          //          sector_offset = 0;
 569          //          state_g = DATA_IDLE_2;
 570          //        }
 571          //        break;
 572          //      }
 573          //      
 574          //      case DATA_IDLE_1:
 575          //      {
 576          //        if(DATA_REQ == ACTIVE)
 577          //        {
 578          //          state_g = DATA_SEND_1;
 579          //        }
 580          //        break;
 581          //      }
 582          //          
 583          //      // Data Send 2
 584          //      case DATA_SEND_2:
 585          //      {
 586          //        spi_en = 1;
 587          //        while((DATA_REQ == ACTIVE) && (TF0 == 0))                 // Can DATA_REQ go inactive while in the loop
 588          //        {
 589          //          SPI_transfer_ISR(buff1[index2_g], & temp8);               // What is temp8
 590          //          index2_g++;
 591          //          if(index2_g > 511) // Buffer 2 empty
 592          //          {
 593          //            if(play_status == 3)                                  // Works only if after FIND_CLUSTER. why?
 594          //            {
 595          //              play_status = 0;
 596          //            }
 597          //            else
 598          //            {
 599          //              state_g = LOAD_BUFFER_1; // Buff 1 and Buff 2 empty
 600          //            }
 601          //          }                                                       // No FIND_CLUSTER
 602          //          else
 603          //          {
 604          //            state_g = DATA_SEND_1; // BUFF 2 empty                //Seems like this is when buffer 2 still has stuff
 605          //          }
 606          //          TF0 = 1;                                                // What does this do? is this the interupt for the whole system to 
             -keep pace
 607          //        }
 608          //        if((DATA_REQ == INACTIVE) && (state_g == DATA_SEND_2))
 609          //        {
 610          //          if(index1_g > 511) // Buffer 1 is empty
C51 COMPILER V9.53.0.0   MAIN                                                              12/15/2015 12:35:43 PAGE 11  

 611          //          {
 612          //            state_g = LOAD_BUFFER_1; // DR inactive and BUFF 1 empty
 613          //          }
 614          //          else
 615          //          {
 616          //            state_g = DATA_IDLE_2; // DR interupt
 617          //          }
 618          //        }
 619          //        spi_en = 0;
 620          //        break;
 621          //      }
 622          //      
 623          //      //Load Buffer 2
 624          //      case LOAD_BUFFER_2:
 625          //      {
 626          //        sector = sector_base_g + sector_offset;
 627          //        read_sector_ISR(sector, buff2);
 628          //        sector_offset++;
 629          //        state_g = DATA_IDLE_1;
 630          //        break;
 631          //      }
 632          //      
 633          //      // Find Cluster 2
 634          //      case FIND_CLUSTER_2:
 635          //      {
 636          //        cluster_g = find_next_cluster_ISR(cluster_g, buff2);
 637          //        if(cluster_g == 0x0FFFFFFF)
 638          //        {
 639          //          play_status = 3;
 640          //          state_g = DATA_IDLE_1;
 641          //        }
 642          //        else
 643          //        {
 644          //          sector_base_g = first_sector_ISR(cluster_g);
 645          //          sector_offset = 0;
 646          //          state_g = DATA_IDLE_1;
 647          //        }
 648          //        break;
 649          //      }
 650          //      
 651          //      case DATA_IDLE_2:
 652          //      {
 653          //        if(DATA_REQ == ACTIVE)
 654          //        {
 655          //          state_g = DATA_SEND_2;
 656          //        }
 657          //        break;
 658          //      }
 659          //      
 660          //    }   
 661          //  }
 662          //} 
 663          //  
 664          
 665          
 666          
 667          
 668          
 669          
 670          
 671          
 672          
C51 COMPILER V9.53.0.0   MAIN                                                              12/15/2015 12:35:43 PAGE 12  

 673          
 674            
 675          //  while(1)
 676          //  {
 677          //    sector_base_g = FirstRootDirSec;
 678          //    while(error_flag == NO_ERRORS)
 679          //    {
 680          //      do
 681          //      {
 682          //        printf("%-35s", "Enter a Block Number: ");
 683          //        block_number = long_serial_input();
 684          //        if(block_number > number_of_entries || block_number == 0)
 685          //        {
 686          //          printf("%-35s", "Number too large.\n\r");
 687          //        }
 688          //      }while(block_number > number_of_entries || block_number == 0);
 689          //      return_entry = Read_Dir_Entry(sector_base_g, block_number, block_info);
 690          //      printf("%-20s", "return_entry");
 691          //      printf("%8.8lX", return_entry);
 692          //      putchar(10);
 693          //      putchar(13);
 694          //      next_entry = return_entry & 0x0FFFFFFF;
 695          //      if(return_entry & 0x10000000)
 696          //      {     
 697          //        printf("%-20s", "was a directory");
 698          //        putchar(10);
 699          //        putchar(13);
 700          //        sector_base_g = first_sector(next_entry);
 701          //        printf("%-20s", "sector_base_g");
 702          //        printf("%8.8lX", sector_base_g);
 703          //        putchar(10);
 704          //        putchar(13);
 705          //        number_of_entries = Print_Directory(sector_base_g, block_info);
 706          //      }
 707          //      if((return_entry & 0x10000000) == 0 && block_number !=0)
 708          //      {
 709          //        printf("%-20s", "was a file");
 710          //        Open_File(next_entry, block_info);
 711          //        number_of_entries = Print_Directory(sector_base_g, block_info);
 712          //      }
 713          //      if(return_entry & 0x80000000)
 714          //      {
 715          //        error_flag = PRINT_ERROR;
 716          //      }
 717          //    }
 718          //    if(error_flag!= NO_ERRORS)
 719          //    {
 720          //      LED4 = 0;
 721          //      putchar(10);
 722          //      putchar(13);
 723          //      printf("%-10s", "ERROR! ");
 724          //      printf("%2.2bX", error_flag);
 725          //      putchar(10);
 726          //      putchar(13);
 727          //      while(1);
 728          //    }
 729          //  }
 730          
 731              
 732              
 733              
 734              
C51 COMPILER V9.53.0.0   MAIN                                                              12/15/2015 12:35:43 PAGE 13  

 735              
 736              
 737              
 738              
 739              
 740              
 741              
 742          //    if(error_flag != NO_ERRORS)
 743          //    {
 744          //      LED4 = 0;
 745          //      LCD_Clear();
 746          //      LCD_Write(COMMAND, LINE1);
 747          //      LCD_Print(1, &error_flag);
 748          //      
 749          //      delay_ms(1000); 
 750          //        printf("%2.2bX ",error_flag);       
 751          //      putchar(10);
 752          //      putchar(13);
 753          //      delay_ms(1000);
 754          //    }
 755          //    else
 756          //    {
 757          //      delay_ms(1000);
 758          //      LCD_Clear();
 759          //      LCD_Write(COMMAND, LINE1);
 760          //      LCD_Print(13, "Enter a Block");
 761          //      LCD_Write(COMMAND, LINE2);
 762          //      LCD_Print(8, "Number: ");
 763          //      //delay_ms(3000);
 764          //      
 765          //      printf("%-35s", "Enter a Block Number");
 766          //      
 767          //      block_number = long_serial_input();   // returns uint32_t 
 768          //      LCD_Clear();
 769          //      
 770          //      error_flag = read_block(block_number, block_info);
 771          //      LCD_Print(13, "Read Success!");
 772          //      print_memory(block_info,512);
 773          //      
 774          //    }
 775          
 776          //    
 777          //    
 778          //    
 779          //    
 780          ////    LCD_Write(COMMAND, LINE1);
 781          ////    LCD_Print(16, "Coltons and Matt");
 782          ////    LCD_Write(COMMAND, LINE2);
 783          ////    LCD_Print(15, "hews LCD Works!");
 784          ////    delay_ms(3000);
 785          ////    LCD_Clear();
 786          //  }
 787          
 788          //}
 789          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2033    ----
   CONSTANT SIZE    =    230    ----
   XDATA SIZE       =   1024    ----
   PDATA SIZE       =   ----    ----
C51 COMPILER V9.53.0.0   MAIN                                                              12/15/2015 12:35:43 PAGE 14  

   DATA SIZE        =   ----       5
   IDATA SIZE       =     41    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
