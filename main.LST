C51 COMPILER V9.53.0.0   MAIN                                                              12/14/2015 14:56:48 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          #include "main.h"
   2          #include "port.h"
   3          #include <stdio.h>
   4          #include "uart.h"
   5          #include "print_bytes.h"
   6          #include "hardware_delay.h"
   7          #include "lcd.h"
   8          #include "spi.h"
   9          #include "SDcard.h"
  10          #include "Long_Serial_In.h"
  11          #include "Directory_Functions.h"
  12          #include "i2c.h"
  13          #include "sta013.h"
  14          
  15          
  16          
  17          
  18            
  19          extern uint16_t idata BPB_BytesPerSec;
  20          extern uint8_t code CONFIG, CONFIG2;
  21          extern uint32_t idata FirstRootDirSec;
  22          
  23          uint8_t idata temp8;
  24          uint32_t idata state_g, sector_offset, cluster_g, play_status;
  25          
  26          uint16_t idata index1_g, index2_g;
  27          uint32_t idata sector_base_g, return_entry, next_entry, block_number, sector;
  28          
  29          uint8_t xdata buff1[512];
  30          uint8_t xdata buff2[512];
  31          
  32          
  33          
  34          
  35          
  36          void timer2_ISR(void) interrupt 5
  37          {
  38   1        LED1 = 1;
  39   1        LED2 = 1;
  40   1        LED3 = 1;
  41   1        LED4 = 1;
  42   1        
  43   1      
  44   1        TF2 = 0;
  45   1        TR0 = 0;
  46   1        TH0 = TIMER0H;
  47   1        TL0 = TIMER0L;
  48   1        TF0 = 0;
  49   1        TR0 = 1;
  50   1        
  51   1        
  52   1        if(state_g == LOAD_BUFFER_1)
  53   1        {
  54   2          if(sector_offset >= 64)
  55   2          {
C51 COMPILER V9.53.0.0   MAIN                                                              12/14/2015 14:56:48 PAGE 2   

  56   3            state_g = FIND_CLUSTER_1;
  57   3          }
  58   2        }
  59   1      
  60   1        if(state_g == LOAD_BUFFER_2)
  61   1        {
  62   2          if(sector_offset >= 64)
  63   2          {
  64   3            state_g = FIND_CLUSTER_2;
  65   3          }
  66   2        }
  67   1      
  68   1      
  69   1        switch(state_g)
  70   1        {
  71   2          // Data Send 1
  72   2          case DATA_SEND_1:
  73   2          {
  74   3            LED1 = 0;
  75   3            LED2 = 1;
  76   3            LED3 = 1;
  77   3            LED4 = 1;
  78   3            spi_en = 1;
  79   3            while((DATA_REQ == ACTIVE) && (TF0 == 0))                 
  80   3            {
  81   4              SPI_transfer_ISR(buff1[index1_g], & temp8);               // What is temp8
  82   4              index1_g++;                                               // Loosing last bit?
  83   4              if(index1_g > 511) // Buffer 1 empty
  84   4              {
  85   5                if(index2_g >511)
  86   5                {
  87   6                  if(play_status == 3)                                  
  88   6                  {
  89   7                    play_status = 0;
  90   7                  }
  91   6                  else
  92   6                  {
  93   7                    state_g = LOAD_BUFFER_2; // Buff 2 and Buff 1 empty
  94   7                  }
  95   6                }                                                       
  96   5                else
  97   5                {
  98   6                  state_g = DATA_SEND_2; // BUFF 1 empty                //Seems like this is when buffer 1 still has stuff
  99   6                }
 100   5                TF0 = 1;
 101   5              }       // What does this do? is this the interupt for the whole system to keep pace
 102   4            }
 103   3            if((DATA_REQ == INACTIVE) && (state_g == DATA_SEND_1))
 104   3            {
 105   4              printf("INACTIVE 1\n\r");
 106   4              if(index2_g > 511) // Buffer 2 is empty
 107   4              {
 108   5                state_g = LOAD_BUFFER_2; // DR inactive and BUFF 2 empty
 109   5              }
 110   4              else
 111   4              {
 112   5                state_g = DATA_IDLE_1; // DR interupt
 113   5              }
 114   4            }
 115   3            if(DATA_REQ == INACTIVE)
 116   3            {
 117   4              printf("INACTIVE 2\n\r");
C51 COMPILER V9.53.0.0   MAIN                                                              12/14/2015 14:56:48 PAGE 3   

 118   4            }
 119   3            spi_en = 0;
 120   3            break;
 121   3          }
 122   2          
 123   2          //Load Buffer 1
 124   2          case LOAD_BUFFER_1:
 125   2          {
 126   3            LED1 = 1;
 127   3            LED2 = 1;
 128   3            LED3 = 1;
 129   3            LED4 = 1;
 130   3            //printf("LOAD_BUFFER_1\n\r");
 131   3            sector = sector_base_g + sector_offset;
 132   3            read_sector_ISR(sector, buff1);
 133   3            //printf("%8.8lX", sector);
 134   3            sector_offset++;
 135   3            state_g = DATA_IDLE_2;
 136   3            index1_g = 0;
 137   3            
 138   3            break;
 139   3          }
 140   2          
 141   2          // Find Cluster 1
 142   2          case FIND_CLUSTER_1:
 143   2          {
 144   3            LED1 = 1;
 145   3            LED2 = 0;
 146   3            LED3 = 1;
 147   3            LED4 = 1;
 148   3            //printf("FIND_CLUSTER_1\n\r");
 149   3            cluster_g = find_next_cluster_ISR(cluster_g, buff1);
 150   3            if(cluster_g == 0x0FFFFFFF) // Last cluster
 151   3            {
 152   4              printf("DONE\n\r");
 153   4              play_status = 3;
 154   4              state_g = DATA_IDLE_2;
 155   4            }
 156   3            else
 157   3            {
 158   4              sector_base_g = first_sector_ISR(cluster_g);
 159   4              sector_offset = 0;
 160   4              state_g = DATA_IDLE_2;
 161   4            }
 162   3            break;
 163   3          }
 164   2          
 165   2          case DATA_IDLE_1:
 166   2          {
 167   3            LED1 = 1;
 168   3        LED2 = 1;
 169   3        LED3 = 1;
 170   3        LED4 = 1;
 171   3            //printf("DATA_IDLE_1\n\r");
 172   3            if(DATA_REQ == ACTIVE)
 173   3            {
 174   4              state_g = DATA_SEND_1;
 175   4            }
 176   3            break;
 177   3          }
 178   2              
 179   2          // Data Send 2
C51 COMPILER V9.53.0.0   MAIN                                                              12/14/2015 14:56:48 PAGE 4   

 180   2          case DATA_SEND_2:
 181   2          {
 182   3            LED1 = 1;
 183   3            LED2 = 1;
 184   3            LED3 = 0;
 185   3            LED4 = 1;
 186   3            //printf("DATA_SEND_2\n\r");
 187   3            spi_en = 1;
 188   3            while((DATA_REQ == ACTIVE) && (TF0 == 0))                 // Can DATA_REQ go inactive while in the loop
 189   3            {
 190   4              SPI_transfer_ISR(buff1[index2_g], & temp8);               // What is temp8
 191   4              index2_g++;
 192   4              if(index2_g > 511) // Buffer 2 empty
 193   4              {
 194   5                if(index1_g > 511) // Buffer 1 empty
 195   5                {
 196   6                  if(play_status == 3)                                  // Works only if after FIND_CLUSTER. why?
 197   6                  {
 198   7                    play_status = 0;
 199   7                  }
 200   6                  else
 201   6                  {
 202   7                    state_g = LOAD_BUFFER_1; // Buff 1 and Buff 2 empty
 203   7                  }
 204   6                }                                                       // No FIND_CLUSTER
 205   5                else
 206   5                {
 207   6                  state_g = DATA_SEND_1; // BUFF 2 empty                //Seems like this is when buffer 2 still has stuff
 208   6                }
 209   5                TF0 = 1;                                                // What does this do? is this the interupt for the whole system to ke
             -ep pace
 210   5              }
 211   4            }
 212   3            if((DATA_REQ == INACTIVE) && (state_g == DATA_SEND_2))
 213   3            {
 214   4              printf("INACTIVE 2\n\r");
 215   4              if(index1_g > 511) // Buffer 1 is empty
 216   4              {
 217   5                state_g = LOAD_BUFFER_1; // DR inactive and BUFF 1 empty
 218   5              }
 219   4              else
 220   4              {
 221   5                state_g = DATA_IDLE_2; // DR interupt
 222   5              }
 223   4            }
 224   3            if(DATA_REQ == INACTIVE)
 225   3            {
 226   4              printf("INACTIVE 2\n\r");
 227   4            }
 228   3            
 229   3            spi_en = 0;
 230   3            break;
 231   3          }
 232   2          
 233   2          //Load Buffer 2
 234   2          case LOAD_BUFFER_2:
 235   2          {
 236   3            LED1 = 1;
 237   3        LED2 = 1;
 238   3        LED3 = 1;
 239   3        LED4 = 1;
 240   3            //printf("LOAD_BUFFER_2\n\r");
C51 COMPILER V9.53.0.0   MAIN                                                              12/14/2015 14:56:48 PAGE 5   

 241   3            sector = sector_base_g + sector_offset;
 242   3            read_sector_ISR(sector, buff2);
 243   3            sector_offset++;
 244   3            state_g = DATA_IDLE_1;
 245   3            index2_g = 0;
 246   3            break;
 247   3          }
 248   2          
 249   2          // Find Cluster 2
 250   2          case FIND_CLUSTER_2:
 251   2          {
 252   3            LED1 = 1;
 253   3        LED2 = 1;
 254   3        LED3 = 1;
 255   3        LED4 = 0;
 256   3            //printf("FIND_CLUSTER_2\n\r");
 257   3            cluster_g = find_next_cluster_ISR(cluster_g, buff2);
 258   3            if(cluster_g == 0x0FFFFFFF)
 259   3            {
 260   4              play_status = 3;
 261   4              state_g = DATA_IDLE_1;
 262   4            }
 263   3            else
 264   3            {
 265   4              sector_base_g = first_sector_ISR(cluster_g);
 266   4              sector_offset = 0;
 267   4              state_g = DATA_IDLE_1;
 268   4            }
 269   3            break;
 270   3          }
 271   2          
 272   2          case DATA_IDLE_2:
 273   2          {
 274   3            LED1 = 1;
 275   3        LED2 = 1;
 276   3        LED3 = 1;
 277   3        LED4 = 1;
 278   3            //printf("DATA_IDLE_2\n\r");
 279   3            if(DATA_REQ == ACTIVE)
 280   3            {
 281   4              state_g = DATA_SEND_2;
 282   4            }
 283   3            break;
 284   3          }           
 285   2        }
 286   1      }
 287          
 288          
 289          
 290          
 291          
 292          
 293          
 294          
 295          void main(void)
 296          {
 297   1        uint8_t error_flag, array_name[2];
 298   1        
 299   1        
 300   1        uint16_t number_of_entries;
 301   1      
 302   1        trig = 1;
C51 COMPILER V9.53.0.0   MAIN                                                              12/14/2015 14:56:48 PAGE 6   

 303   1        LED1=0;
 304   1        UART_Init();
 305   1        LCD_Init();
 306   1        SPI_master_init(400000); // Set clock rate to that speed in Hz
 307   1        error_flag = SDcard_init();
 308   1        printf("%-20s", "Mounting Drive");
 309   1        putchar(10);
 310   1        putchar(13);
 311   1        error_flag = mount_drive(buff1);
 312   1        number_of_entries = Print_Directory(FirstRootDirSec, buff1);
 313   1        LCD_Clear();
 314   1        LCD_Write(COMMAND, LINE1);
 315   1      
 316   1        LCD_Print(9,"init done");
 317   1        LED2=0;
 318   1        array_name[0] = 0x01;
 319   1        array_name[1] = 0xAC;
 320   1        error_flag = test_I2C(array_name);
 321   1      if (error_flag != NO_ERRORS)
 322   1        {
 323   2          LED4=0;
 324   2          printf("%-10s", "ERROR1! ");
 325   2          printf("%2.2bX", error_flag);
 326   2          putchar(10);
 327   2          putchar(13);
 328   2        }
 329   1      
 330   1        error_flag = config_file();
 331   1        if (error_flag != NO_ERRORS)
 332   1        {
 333   2          LED4=0;
 334   2          printf("%-10s", "config err ");
 335   2          printf("%2.2bX", error_flag);
 336   2          putchar(10);
 337   2          putchar(13);
 338   2        }
 339   1          
 340   1      
 341   1        LED3=0;
 342   1        
 343   1      
 344   1        if (error_flag != NO_ERRORS)
 345   1        {
 346   2          LED4=0;
 347   2          printf("%-10s", "test_i2c err ");
 348   2          printf("%2.2bX", error_flag);
 349   2          putchar(10);
 350   2          putchar(13);
 351   2        }
 352   1      
 353   1        TH2 = TIMER2H;
 354   1        TL2 = TIMER2L;
 355   1        T2CON = 0x80;
 356   1        TR0 = 0;
 357   1        TH0 = TIMER0H;
 358   1        TL0 = TIMER0L;
 359   1        TF0 = 0;  
 360   1        TMOD |= 0x01;
 361   1        
 362   1        ET2 = 1;                      /* Enable Timer 2 Interrupts */
 363   1        EA = 1;                       /* Global Interrupt Enable */
 364   1      
C51 COMPILER V9.53.0.0   MAIN                                                              12/14/2015 14:56:48 PAGE 7   

 365   1      
 366   1      
 367   1      
 368   1      
 369   1      
 370   1      
 371   1      
 372   1      
 373   1      
 374   1      
 375   1      
 376   1      /************************
 377   1      **        Loop         **
 378   1      ************************/
 379   1      
 380   1        
 381   1        while(1)
 382   1        { 
 383   2          sector_base_g = FirstRootDirSec;
 384   2          while(error_flag == NO_ERRORS)
 385   2          {
 386   3            do
 387   3            {
 388   4              printf("%-35s", "Enter a Block Number: ");
 389   4              block_number = long_serial_input();
 390   4              if(block_number > number_of_entries || block_number == 0)
 391   4              {
 392   5                printf("%-35s", "Number too large.\n\r");
 393   5              }
 394   4            }while(block_number > number_of_entries || block_number == 0);
 395   3            return_entry = Read_Dir_Entry(sector_base_g, block_number, buff1);
 396   3            printf("%-20s", "return_entry");
 397   3            printf("%8.8lX", return_entry);
 398   3            putchar(10);
 399   3            putchar(13);
 400   3            next_entry = return_entry & 0x0FFFFFFF;
 401   3            if(return_entry & 0x10000000)
 402   3            {     
 403   4              printf("%-20s", "was a directory");
 404   4              putchar(10);
 405   4              putchar(13);
 406   4              sector_base_g = first_sector(next_entry);
 407   4              printf("%-20s", "sector_base_g");
 408   4              printf("%8.8lX", sector_base_g);
 409   4              putchar(10);
 410   4              putchar(13);
 411   4              number_of_entries = Print_Directory(sector_base_g, buff1);
 412   4            }
 413   3            if((return_entry & 0x10000000) == 0 && block_number !=0)
 414   3            {
 415   4              sector_offset = 0;
 416   4              printf("%-20s", "was a file");
 417   4              //Open_File(next_entry, buff1);
 418   4              sector_base_g = first_sector(next_entry);
 419   4              sector = sector_base_g + sector_offset;
 420   4              read_sector(sector, buff1);
 421   4              print_memory(buff1, BPB_BytesPerSec);
 422   4              sector_offset++;
 423   4              sector = sector_base_g + sector_offset;
 424   4              read_sector(sector, buff2);
 425   4              print_memory(buff2, BPB_BytesPerSec);
 426   4              sector_offset++;
C51 COMPILER V9.53.0.0   MAIN                                                              12/14/2015 14:56:48 PAGE 8   

 427   4              state_g = DATA_SEND_1;
 428   4      
 429   4      
 430   4              
 431   4              play_status = 1; // Run
 432   4              TF2 = 0;
 433   4              TR2 = 1;
 434   4              index1_g = 0;
 435   4              index2_g = 0;
 436   4              while(play_status != 0)
 437   4              { 
 438   5                
 439   5                PCON = 1; // Idle mode???
 440   5                
 441   5              }
 442   4              TR2 = 0;
 443   4              
 444   4              number_of_entries = Print_Directory(sector_base_g, buff1);
 445   4            }
 446   3            if(return_entry & 0x80000000)
 447   3            {
 448   4              error_flag = PRINT_ERROR;
 449   4            }
 450   3          }
 451   2          if(error_flag!= NO_ERRORS)
 452   2          {
 453   3            LED4 = 0;
 454   3            putchar(10);
 455   3            putchar(13);
 456   3            printf("%-10s", "ERROR! ");
 457   3            printf("%2.2bX", error_flag);
 458   3            putchar(10);
 459   3            putchar(13);
 460   3            while(1);
 461   3          }
 462   2        }
 463   1      }
 464              
 465              
 466              
 467              
 468              
 469          
 470          
 471          
 472          
 473          
 474              
 475              
 476              
 477              
 478              
 479          //    
 480          //    
 481          //    if(state_g == LOAD_BUFFER_1)
 482          //    {
 483          //      if(sector_offset >= 64)
 484          //      {
 485          //        state_g = FIND_CLUSTER_1;
 486          //      }
 487          //    }
 488          
C51 COMPILER V9.53.0.0   MAIN                                                              12/14/2015 14:56:48 PAGE 9   

 489          //    if(state_g == LOAD_BUFFER_2)
 490          //    {
 491          //      if(sector_offset >= 64)
 492          //      {
 493          //        state_g = FIND_CLUSTER_2;
 494          //      }
 495          //    }
 496          
 497          
 498          //    switch(state_g)
 499          //    {
 500          //      // Data Send 1
 501          //      case DATA_SEND_1:
 502          //      {
 503          //        spi_en = 1;
 504          //        while((DATA_REQ == ACTIVE) && (TF0 == 0))                 // Can DATA_REQ go inactive while in the loop
 505          //        {
 506          //          SPI_transfer_ISR(buff1[index1_g], & temp8);               // What is temp8
 507          //          index1_g++;
 508          //          if(index1_g > 511) // Buffer 1 empty
 509          //          {
 510          //            if(play_status == 3)                                  // Works only if after FIND_CLUSTER. why?
 511          //            {
 512          //              play_status = 0;
 513          //              // state_g = DATA_SEND_2;                           // I think this is where it goes
 514          //            }
 515          //            else
 516          //            {
 517          //              state_g = LOAD_BUFFER_2; // Buff 2 and Buff 1 empty
 518          //            }
 519          //          }                                                       // No FIND_CLUSTER
 520          //          else
 521          //          {
 522          //            state_g = DATA_SEND_2; // BUFF 1 empty                //Seems like this is when buffer 1 still has stuff
 523          //          }
 524          //          TF0 = 1;                                                // What does this do? is this the interupt for the whole system to 
             -keep pace
 525          //        }
 526          //        if((DATA_REQ == INACTIVE) && (state_g == DATA_SEND_1))
 527          //        {
 528          //          if(index2_g > 511) // Buffer 2 is empty
 529          //          {
 530          //            state_g = LOAD_BUFFER_2; // DR inactive and BUFF 2 empty
 531          //          }
 532          //          else
 533          //          {
 534          //            state_g = DATA_IDLE_1; // DR interupt
 535          //          }
 536          //        }
 537          //        spi_en = 0;
 538          //        break;
 539          //      }
 540          //      
 541          //      //Load Buffer 1
 542          //      case LOAD_BUFFER_1:
 543          //      {
 544          //        sector = sector_base_g + sector_offset;
 545          //        read_sector_ISR(sector, buff1);
 546          //        sector_offset++;
 547          //        state_g = DATA_IDLE_2;
 548          //        break;
 549          //      }
C51 COMPILER V9.53.0.0   MAIN                                                              12/14/2015 14:56:48 PAGE 10  

 550          //      
 551          //      // Find Cluster 1
 552          //      case FIND_CLUSTER_1:
 553          //      {
 554          //        cluster_g = find_next_cluster_ISR(cluster_g, buff1);
 555          //        if(cluster_g == 0x0FFFFFFF)
 556          //        {
 557          //          play_status = 3;
 558          //          state_g = DATA_IDLE_2;
 559          //        }
 560          //        else
 561          //        {
 562          //          sector_base_g = first_sector_ISR(cluster_g);
 563          //          sector_offset = 0;
 564          //          state_g = DATA_IDLE_2;
 565          //        }
 566          //        break;
 567          //      }
 568          //      
 569          //      case DATA_IDLE_1:
 570          //      {
 571          //        if(DATA_REQ == ACTIVE)
 572          //        {
 573          //          state_g = DATA_SEND_1;
 574          //        }
 575          //        break;
 576          //      }
 577          //          
 578          //      // Data Send 2
 579          //      case DATA_SEND_2:
 580          //      {
 581          //        spi_en = 1;
 582          //        while((DATA_REQ == ACTIVE) && (TF0 == 0))                 // Can DATA_REQ go inactive while in the loop
 583          //        {
 584          //          SPI_transfer_ISR(buff1[index2_g], & temp8);               // What is temp8
 585          //          index2_g++;
 586          //          if(index2_g > 511) // Buffer 2 empty
 587          //          {
 588          //            if(play_status == 3)                                  // Works only if after FIND_CLUSTER. why?
 589          //            {
 590          //              play_status = 0;
 591          //            }
 592          //            else
 593          //            {
 594          //              state_g = LOAD_BUFFER_1; // Buff 1 and Buff 2 empty
 595          //            }
 596          //          }                                                       // No FIND_CLUSTER
 597          //          else
 598          //          {
 599          //            state_g = DATA_SEND_1; // BUFF 2 empty                //Seems like this is when buffer 2 still has stuff
 600          //          }
 601          //          TF0 = 1;                                                // What does this do? is this the interupt for the whole system to 
             -keep pace
 602          //        }
 603          //        if((DATA_REQ == INACTIVE) && (state_g == DATA_SEND_2))
 604          //        {
 605          //          if(index1_g > 511) // Buffer 1 is empty
 606          //          {
 607          //            state_g = LOAD_BUFFER_1; // DR inactive and BUFF 1 empty
 608          //          }
 609          //          else
 610          //          {
C51 COMPILER V9.53.0.0   MAIN                                                              12/14/2015 14:56:48 PAGE 11  

 611          //            state_g = DATA_IDLE_2; // DR interupt
 612          //          }
 613          //        }
 614          //        spi_en = 0;
 615          //        break;
 616          //      }
 617          //      
 618          //      //Load Buffer 2
 619          //      case LOAD_BUFFER_2:
 620          //      {
 621          //        sector = sector_base_g + sector_offset;
 622          //        read_sector_ISR(sector, buff2);
 623          //        sector_offset++;
 624          //        state_g = DATA_IDLE_1;
 625          //        break;
 626          //      }
 627          //      
 628          //      // Find Cluster 2
 629          //      case FIND_CLUSTER_2:
 630          //      {
 631          //        cluster_g = find_next_cluster_ISR(cluster_g, buff2);
 632          //        if(cluster_g == 0x0FFFFFFF)
 633          //        {
 634          //          play_status = 3;
 635          //          state_g = DATA_IDLE_1;
 636          //        }
 637          //        else
 638          //        {
 639          //          sector_base_g = first_sector_ISR(cluster_g);
 640          //          sector_offset = 0;
 641          //          state_g = DATA_IDLE_1;
 642          //        }
 643          //        break;
 644          //      }
 645          //      
 646          //      case DATA_IDLE_2:
 647          //      {
 648          //        if(DATA_REQ == ACTIVE)
 649          //        {
 650          //          state_g = DATA_SEND_2;
 651          //        }
 652          //        break;
 653          //      }
 654          //      
 655          //    }   
 656          //  }
 657          //} 
 658          //  
 659          
 660          
 661          
 662          
 663          
 664          
 665          
 666          
 667          
 668          
 669            
 670          //  while(1)
 671          //  {
 672          //    sector_base_g = FirstRootDirSec;
C51 COMPILER V9.53.0.0   MAIN                                                              12/14/2015 14:56:48 PAGE 12  

 673          //    while(error_flag == NO_ERRORS)
 674          //    {
 675          //      do
 676          //      {
 677          //        printf("%-35s", "Enter a Block Number: ");
 678          //        block_number = long_serial_input();
 679          //        if(block_number > number_of_entries || block_number == 0)
 680          //        {
 681          //          printf("%-35s", "Number too large.\n\r");
 682          //        }
 683          //      }while(block_number > number_of_entries || block_number == 0);
 684          //      return_entry = Read_Dir_Entry(sector_base_g, block_number, block_info);
 685          //      printf("%-20s", "return_entry");
 686          //      printf("%8.8lX", return_entry);
 687          //      putchar(10);
 688          //      putchar(13);
 689          //      next_entry = return_entry & 0x0FFFFFFF;
 690          //      if(return_entry & 0x10000000)
 691          //      {     
 692          //        printf("%-20s", "was a directory");
 693          //        putchar(10);
 694          //        putchar(13);
 695          //        sector_base_g = first_sector(next_entry);
 696          //        printf("%-20s", "sector_base_g");
 697          //        printf("%8.8lX", sector_base_g);
 698          //        putchar(10);
 699          //        putchar(13);
 700          //        number_of_entries = Print_Directory(sector_base_g, block_info);
 701          //      }
 702          //      if((return_entry & 0x10000000) == 0 && block_number !=0)
 703          //      {
 704          //        printf("%-20s", "was a file");
 705          //        Open_File(next_entry, block_info);
 706          //        number_of_entries = Print_Directory(sector_base_g, block_info);
 707          //      }
 708          //      if(return_entry & 0x80000000)
 709          //      {
 710          //        error_flag = PRINT_ERROR;
 711          //      }
 712          //    }
 713          //    if(error_flag!= NO_ERRORS)
 714          //    {
 715          //      LED4 = 0;
 716          //      putchar(10);
 717          //      putchar(13);
 718          //      printf("%-10s", "ERROR! ");
 719          //      printf("%2.2bX", error_flag);
 720          //      putchar(10);
 721          //      putchar(13);
 722          //      while(1);
 723          //    }
 724          //  }
 725          
 726              
 727              
 728              
 729              
 730              
 731              
 732              
 733              
 734              
C51 COMPILER V9.53.0.0   MAIN                                                              12/14/2015 14:56:48 PAGE 13  

 735              
 736              
 737          //    if(error_flag != NO_ERRORS)
 738          //    {
 739          //      LED4 = 0;
 740          //      LCD_Clear();
 741          //      LCD_Write(COMMAND, LINE1);
 742          //      LCD_Print(1, &error_flag);
 743          //      
 744          //      delay_ms(1000); 
 745          //        printf("%2.2bX ",error_flag);       
 746          //      putchar(10);
 747          //      putchar(13);
 748          //      delay_ms(1000);
 749          //    }
 750          //    else
 751          //    {
 752          //      delay_ms(1000);
 753          //      LCD_Clear();
 754          //      LCD_Write(COMMAND, LINE1);
 755          //      LCD_Print(13, "Enter a Block");
 756          //      LCD_Write(COMMAND, LINE2);
 757          //      LCD_Print(8, "Number: ");
 758          //      //delay_ms(3000);
 759          //      
 760          //      printf("%-35s", "Enter a Block Number");
 761          //      
 762          //      block_number = long_serial_input();   // returns uint32_t 
 763          //      LCD_Clear();
 764          //      
 765          //      error_flag = read_block(block_number, block_info);
 766          //      LCD_Print(13, "Read Success!");
 767          //      print_memory(block_info,512);
 768          //      
 769          //    }
 770          
 771          //    
 772          //    
 773          //    
 774          //    
 775          ////    LCD_Write(COMMAND, LINE1);
 776          ////    LCD_Print(16, "Coltons and Matt");
 777          ////    LCD_Write(COMMAND, LINE2);
 778          ////    LCD_Print(15, "hews LCD Works!");
 779          ////    delay_ms(3000);
 780          ////    LCD_Clear();
 781          //  }
 782          
 783          //}
 784          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2074    ----
   CONSTANT SIZE    =    230    ----
   XDATA SIZE       =   1024    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       5
   IDATA SIZE       =     41    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
