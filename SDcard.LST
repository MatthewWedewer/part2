C51 COMPILER V9.53.0.0   SDCARD                                                            12/14/2015 14:47:00 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE SDCARD
OBJECT MODULE PLACED IN SDcard.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE SDcard.c OPTIMIZE(8,SPEED) DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          #include "main.h"
   2          #include "port.h"
   3          #include "SDcard.h"
   4          #include "spi.h"
   5          #include "lcd.h"
   6          #include "hardware_delay.h"
   7          #include "print_bytes.h"
   8          #include <stdio.h>
   9          
  10          
  11          uint8_t SDcard_init()
  12          {
  13   1        uint8_t return_value[5];
  14   1        uint8_t error_flag, index, dat;
  15   1        
  16   1        AUXR = 0x0C;
  17   1        //Buffer ?
  18   1        ncs = 1;
  19   1        for(index = 0; index < 10; index++)
  20   1        {
  21   2          SPI_transfer(0xFF, return_value);
  22   2        }
  23   1        
  24   1        
  25   1        // Send CMD0 //
  26   1        
  27   1        error_flag = trans_CMD0(return_value);
  28   1        
  29   1        
  30   1        for (index=0;index<5;index++)
  31   1          {
  32   2             dat=return_value[index];
  33   2             printf("%2.2bX ",dat);
  34   2          }
  35   1        putchar(10);
  36   1        putchar(13);
  37   1        delay_ms(100);
  38   1        
  39   1      
  40   1      
  41   1        // Send CMD8 //
  42   1        if(error_flag == NO_ERRORS)
  43   1        {
  44   2          error_flag = trans_CMD8(return_value);
  45   2        }
  46   1        
  47   1      
  48   1      
  49   1        for (index=0;index<5;index++)
  50   1          {
  51   2             dat=return_value[index];
  52   2             printf("%2.2bX ",dat);
  53   2          }
  54   1        putchar(10);
  55   1        putchar(13);
C51 COMPILER V9.53.0.0   SDCARD                                                            12/14/2015 14:47:00 PAGE 2   

  56   1        delay_ms(100);
  57   1      
  58   1        // Send CMD58 //
  59   1        if(error_flag == NO_ERRORS)
  60   1        {
  61   2          error_flag = trans_CMD58(return_value);
  62   2          if(return_value[0] != 0x01)
  63   2          {
  64   3            error_flag = WRONG_RESPONSE;
  65   3            LED2 = 0;
  66   3          }
  67   2        }
  68   1        
  69   1      
  70   1      
  71   1        for (index=0;index<5;index++)
  72   1          {
  73   2             dat=return_value[index];
  74   2             printf("%2.2bX ",dat);
  75   2          }
  76   1        putchar(10);
  77   1        putchar(13);
  78   1        delay_ms(100);
  79   1      
  80   1        // Send ACMD41 //
  81   1        if(error_flag == NO_ERRORS)
  82   1        {
  83   2          error_flag = trans_ACMD41(return_value);
  84   2        }
  85   1      
  86   1      
  87   1      
  88   1        for (index=0;index<5;index++)
  89   1          {
  90   2             dat=return_value[index];
  91   2             printf("%2.2bX ",dat);
  92   2          }
  93   1        putchar(10);
  94   1        putchar(13);
  95   1        delay_ms(100);
  96   1        
  97   1        // Send CMD58 //
  98   1        if(error_flag == NO_ERRORS)
  99   1        {
 100   2          error_flag = trans_CMD58(return_value);
 101   2          if(return_value[1] & 0xC0) //bit 31 and 30 are set
 102   2          {
 103   3            //High Capacity
 104   3          }
 105   2          else if(return_value[1] & 0x80) // only bit 31 is set
 106   2          {
 107   3            //Standard Capacity
 108   3            error_flag = WRONG_SDCARD;
 109   3          }
 110   2          else
 111   2          {
 112   3            error_flag = WRONG_RESPONSE;
 113   3          }
 114   2        }
 115   1      
 116   1      
 117   1        for (index=0;index<5;index++)
C51 COMPILER V9.53.0.0   SDCARD                                                            12/14/2015 14:47:00 PAGE 3   

 118   1          {
 119   2             dat=return_value[index];
 120   2             printf("%2.2bX ",dat);
 121   2          }
 122   1        putchar(10);
 123   1        putchar(13);
 124   1        delay_ms(100);
 125   1        
 126   1        if(error_flag != NO_ERRORS) // LED4 is the error light and this should also be redundent.
 127   1        {
 128   2          LED4 = 0;
 129   2        }
 130   1        ncs = 1; // should not be needed but just in case
 131   1        
 132   1        return error_flag; 
 133   1      }
 134          
 135          
 136          
 137          
 138          
 139          
 140          
 141          
 142          
 143          
 144          
 145          
 146          
 147          
 148          
 149          
 150          uint8_t trans_CMD0(uint8_t *return_value)
 151          {
 152   1        uint8_t error_flag;
 153   1      
 154   1        // Send CMD0
 155   1        ncs = 0;
 156   1        error_flag = send_command(0, 0);
 157   1        if(error_flag == NO_ERRORS)
 158   1        {
 159   2          error_flag = get_response(1, return_value);
 160   2        }
 161   1        if(error_flag == NO_ERRORS)
 162   1        {
 163   2          if(return_value[0] != 0x01)
 164   2          {
 165   3            error_flag = WRONG_RESPONSE;
 166   3          }
 167   2        }
 168   1        ncs = 1;
 169   1        
 170   1        return error_flag;
 171   1      }
 172          
 173          
 174          
 175          
 176          
 177          uint8_t trans_CMD8(uint8_t *return_value)
 178          {
 179   1        uint8_t error_flag;
C51 COMPILER V9.53.0.0   SDCARD                                                            12/14/2015 14:47:00 PAGE 4   

 180   1        // Send CMD8
 181   1        ncs = 0;
 182   1        error_flag = send_command(8, 0x000001AA);
 183   1        if(error_flag == NO_ERRORS)
 184   1        {
 185   2          error_flag = get_response(5, return_value);
 186   2        }
 187   1        if(return_value[0] == 0x05)
 188   1          error_flag = VERSION_1_SD;
 189   1        else if(return_value[0] != 0x01)
 190   1          error_flag = FAIL_SDINIT;
 191   1        ncs = 1;
 192   1        return error_flag;
 193   1      }
 194          
 195          
 196          
 197          
 198          
 199          uint8_t trans_CMD58(uint8_t *return_value)
 200          {
 201   1        uint8_t error_flag;
 202   1        // SEND CMD58
 203   1        ncs = 0;
 204   1        error_flag = send_command(58, 0);
 205   1        if(error_flag == NO_ERRORS)
 206   1        {
 207   2          error_flag = get_response(5, return_value);
 208   2        }
 209   1        return error_flag;
 210   1      }
 211          
 212          
 213          
 214          
 215          uint8_t trans_ACMD41(uint8_t *return_value)
 216          {
 217   1        uint8_t error_flag, timeout;
 218   1        uint32_t ACMD41_argum = 0x40000000;
 219   1      
 220   1        
 221   1        // Send ACMD41
 222   1        
 223   1        ncs = 0;
 224   1        
 225   1      
 226   1        timeout = 0;
 227   1        do
 228   1        {
 229   2          timeout++;
 230   2          error_flag = send_command(55, 0);
 231   2          if(error_flag == NO_ERRORS)
 232   2            error_flag = get_response(1, return_value);
 233   2          if(!(return_value[0] == 0x00 || return_value[0] == 0x01))
 234   2            error_flag = SPI_ERROR;
 235   2          if(error_flag == NO_ERRORS)
 236   2            error_flag = send_command(41, ACMD41_argum);
 237   2          if(error_flag == NO_ERRORS)
 238   2            error_flag = get_response(1, return_value);
 239   2          if(!(return_value[0] == 0x00 || return_value[0] == 0x01))
 240   2            error_flag = SPI_ERROR;
 241   2          timeout++;
C51 COMPILER V9.53.0.0   SDCARD                                                            12/14/2015 14:47:00 PAGE 5   

 242   2        }while(return_value[0] != 0x00 && timeout != 0 && error_flag == NO_ERRORS);
 243   1        if(timeout == 0)
 244   1        {
 245   2          error_flag = TIMEOUT_ERROR;
 246   2        }
 247   1        ncs = 1;
 248   1        
 249   1        return error_flag;
 250   1      }
 251          
 252          
 253          
 254          
 255          
 256          
 257          
 258          
 259          
 260          uint8_t send_command(uint8_t cmd, uint32_t argum)
 261          {
 262   1        uint8_t error_flag, send_val, return_val, index;
 263   1        if(cmd < 64)
 264   1        {
 265   2          send_val = 0x40 | cmd;
 266   2          error_flag = SPI_transfer(send_val, &return_val);
 267   2          index = 24;
 268   2          while((error_flag == NO_ERRORS)&(index<25))
 269   2          {
 270   3            send_val = (uint8_t)(argum >> index);
 271   3            error_flag = SPI_transfer(send_val, &return_val);
 272   3            index -= 8;
 273   3          }
 274   2          if(cmd == 0)
 275   2            send_val = 0x95;
 276   2          else if(cmd == 8)
 277   2            send_val = 0x87;
 278   2          else
 279   2            send_val = 0x01;
 280   2          if(error_flag == NO_ERRORS)
 281   2            error_flag = SPI_transfer(send_val, &return_val);
 282   2          if(error_flag != NO_ERRORS)
 283   2            error_flag = SPI_ERROR;
 284   2        }
 285   1        else
 286   1          error_flag = ILLEGAL_COMMAND;
 287   1        return error_flag;
 288   1      }
 289          
 290          
 291          
 292          
 293          
 294          uint8_t send_command_ISR(uint8_t cmd, uint32_t argum)
 295          {
 296   1        uint8_t idata error_flag, send_val, return_val, index;
 297   1        if(cmd < 64)
 298   1        {
 299   2          send_val = 0x40 | cmd;
 300   2          error_flag = SPI_transfer_ISR(send_val, &return_val);
 301   2          index = 24;
 302   2          while((error_flag == NO_ERRORS)&(index<25))
 303   2          {
C51 COMPILER V9.53.0.0   SDCARD                                                            12/14/2015 14:47:00 PAGE 6   

 304   3            send_val = (uint8_t)(argum >> index);
 305   3            error_flag = SPI_transfer_ISR(send_val, &return_val);
 306   3            index -= 8;
 307   3          }
 308   2          if(cmd == 0)
 309   2            send_val = 0x95;
 310   2          else if(cmd == 8)
 311   2            send_val = 0x87;
 312   2          else
 313   2            send_val = 0x01;
 314   2          if(error_flag == NO_ERRORS)
 315   2            error_flag = SPI_transfer_ISR(send_val, &return_val);
 316   2          if(error_flag != NO_ERRORS)
 317   2            error_flag = SPI_ERROR;
 318   2        }
 319   1        else
 320   1          error_flag = ILLEGAL_COMMAND;
 321   1        return error_flag;
 322   1      }
 323          
 324          
 325          
 326          uint8_t get_response(uint8_t num_bytes, uint8_t *array_out)
 327          {
 328   1        uint8_t timeout, error_flag, recieve_value;
 329   1        uint8_t index;
 330   1        timeout = 0;
 331   1        error_flag = NO_ERRORS;
 332   1        do
 333   1        {
 334   2          error_flag = SPI_transfer(0xFF, &recieve_value);
 335   2          timeout++;
 336   2        }while((timeout!=0)&&(error_flag == NO_ERRORS)&&(recieve_value == 0xFF));
 337   1        *array_out = recieve_value;
 338   1        if(timeout == 0)
 339   1          error_flag = TIMEOUT_ERROR;
 340   1        else if(error_flag != NO_ERRORS)
 341   1          error_flag = SPI_ERROR;
 342   1        else if((recieve_value != 0x01)&&(recieve_value != 0x00))
 343   1          error_flag = SPI_ERROR;
 344   1        else if(num_bytes > 1)
 345   1        {
 346   2          for(index = 1; index < num_bytes; index++)
 347   2          {
 348   3            SPI_transfer(0xFF, &recieve_value);
 349   3            *(array_out+index) = recieve_value;
 350   3          }
 351   2        }
 352   1        if(error_flag == NO_ERRORS)
 353   1          error_flag = SPI_transfer(0xFF, &recieve_value);
 354   1        return error_flag;
 355   1      }
 356          
 357          
 358          
 359          
 360          
 361          uint8_t get_response_no_end(uint16_t num_bytes, uint8_t *array_out)
 362          {
 363   1        uint8_t timeout, error_flag, recieve_value;
 364   1        uint16_t index;
 365   1        timeout = 0;
C51 COMPILER V9.53.0.0   SDCARD                                                            12/14/2015 14:47:00 PAGE 7   

 366   1        error_flag = NO_ERRORS;
 367   1        for(index = 0; index < num_bytes; index++)
 368   1        {
 369   2          SPI_transfer(0xFF, &recieve_value);
 370   2          array_out[index] = recieve_value;
 371   2        }
 372   1        return error_flag;
 373   1      }
 374          
 375          
 376          
 377          
 378          uint8_t get_response_no_end_ISR(uint16_t num_bytes, uint8_t *array_out)
 379          {
 380   1        uint8_t idata timeout, error_flag, recieve_value;
 381   1        uint16_t idata index;
 382   1        timeout = 0;
 383   1        error_flag = NO_ERRORS;
 384   1        for(index = 0; index < num_bytes; index++)
 385   1        {
 386   2          SPI_transfer_ISR(0xFF, &recieve_value);
 387   2          array_out[index] = recieve_value;
 388   2        }
 389   1        return error_flag;
 390   1      }
 391          
 392          
 393          
 394          
 395          
 396          
 397          
 398          uint8_t read_block(uint32_t block_number, uint8_t *block_info)
 399          {
 400   1        uint8_t error_flag, timeout;
 401   1        uint8_t return_value[5];
 402   1        ncs = 0;
 403   1        timeout = 0;
 404   1        error_flag = send_command(17, block_number);
 405   1        do
 406   1        {
 407   2          timeout++;
 408   2          if(error_flag == NO_ERRORS)
 409   2            error_flag = get_response_no_end(1, &return_value);
 410   2        }while(return_value[0] != 0x00 && timeout != 0);
 411   1      
 412   1      
 413   1        if(timeout == 0)
 414   1        {
 415   2          error_flag = TIMEOUT_ERROR;
 416   2        }
 417   1        timeout = 0;
 418   1        do
 419   1        {
 420   2          timeout++;
 421   2          if(error_flag == NO_ERRORS)
 422   2            error_flag = get_response_no_end(1, &return_value);
 423   2        }while(return_value[0] != 0xFE    && timeout != 0 && error_flag == NO_ERRORS);
 424   1        
 425   1      
 426   1        
 427   1        if(timeout == 0)
C51 COMPILER V9.53.0.0   SDCARD                                                            12/14/2015 14:47:00 PAGE 8   

 428   1        {
 429   2          error_flag = TIMEOUT_ERROR;
 430   2        }
 431   1        if((return_value[0] & 0xF0 )== 0x00)
 432   1        {
 433   2          error_flag = SDCARD_ERROR;
 434   2        }
 435   1        if(error_flag == NO_ERRORS)
 436   1        {
 437   2          error_flag = get_response_no_end(512, block_info);
 438   2        }
 439   1        if(error_flag == NO_ERRORS)
 440   1        {
 441   2          error_flag = get_response_no_end(3, &return_value);
 442   2      //    CRC16 = return_value[0] * 256 + return_value[1]; Check sum, dont care
 443   2        }
 444   1        ncs = 1;
 445   1        
 446   1        return error_flag;
 447   1        
 448   1      }
 449          
 450          
 451          uint8_t read_block_ISR(uint32_t block_number, uint8_t *block_info)
 452          {
 453   1        uint8_t idata error_flag, timeout;
 454   1        uint8_t idata return_value[5];
 455   1        ncs = 0;
 456   1        timeout = 0;
 457   1        error_flag = send_command_ISR(17, block_number);
 458   1        do
 459   1        {
 460   2          timeout++;
 461   2          if(error_flag == NO_ERRORS)
 462   2            error_flag = get_response_no_end_ISR(1, &return_value);
 463   2        }while(return_value[0] != 0x00 && timeout != 0);
 464   1      
 465   1      
 466   1        if(timeout == 0)
 467   1        {
 468   2          error_flag = TIMEOUT_ERROR;
 469   2        }
 470   1        timeout = 0;
 471   1        do
 472   1        {
 473   2          timeout++;
 474   2          if(error_flag == NO_ERRORS)
 475   2            error_flag = get_response_no_end_ISR(1, &return_value);
 476   2        }while(return_value[0] != 0xFE    && timeout != 0 && error_flag == NO_ERRORS);
 477   1        
 478   1      
 479   1        
 480   1        if(timeout == 0)
 481   1        {
 482   2          error_flag = TIMEOUT_ERROR;
 483   2        }
 484   1        if((return_value[0] & 0xF0 )== 0x00)
 485   1        {
 486   2          error_flag = SDCARD_ERROR;
 487   2        }
 488   1        if(error_flag == NO_ERRORS)
 489   1        {
C51 COMPILER V9.53.0.0   SDCARD                                                            12/14/2015 14:47:00 PAGE 9   

 490   2          error_flag = get_response_no_end_ISR(512, block_info);
 491   2        }
 492   1        if(error_flag == NO_ERRORS)
 493   1        {
 494   2          error_flag = get_response_no_end_ISR(3, &return_value);
 495   2      //    CRC16 = return_value[0] * 256 + return_value[1]; Check sum, dont care
 496   2        }
 497   1        ncs = 1;
 498   1        
 499   1        return error_flag;
 500   1        
 501   1      }
 502          
 503          
 504          
 505          uint8_t read_sector(uint32_t block_number, uint8_t *block_info)
 506          {
 507   1        uint8_t error_flag, timeout;
 508   1        uint8_t return_value[5];
 509   1        ncs = 0;
 510   1        timeout = 0;
 511   1        error_flag = send_command(17, block_number);
 512   1        do
 513   1        {
 514   2          timeout++;
 515   2          if(error_flag == NO_ERRORS)
 516   2            error_flag = get_response_no_end(1, &return_value);
 517   2        }while(return_value[0] != 0x00 && timeout != 0);
 518   1      
 519   1      
 520   1        if(timeout == 0)
 521   1        {
 522   2          error_flag = TIMEOUT_ERROR;
 523   2        }
 524   1        timeout = 0;
 525   1        do
 526   1        {
 527   2          timeout++;
 528   2          if(error_flag == NO_ERRORS)
 529   2            error_flag = get_response_no_end(1, &return_value);
 530   2        }while(return_value[0] != 0xFE    && timeout != 0 && error_flag == NO_ERRORS);
 531   1        
 532   1      
 533   1        
 534   1        if(timeout == 0)
 535   1        {
 536   2          error_flag = TIMEOUT_ERROR;
 537   2        }
 538   1        if((return_value[0] & 0xF0 )== 0x00)
 539   1        {
 540   2          error_flag = SDCARD_ERROR;
 541   2        }
 542   1        if(error_flag == NO_ERRORS)
 543   1        {
 544   2          error_flag = get_response_no_end(512, block_info);
 545   2        }
 546   1        if(error_flag == NO_ERRORS)
 547   1        {
 548   2          error_flag = get_response_no_end(3, &return_value);
 549   2      //    CRC16 = return_value[0] * 256 + return_value[1]; Check sum, dont care
 550   2        }
 551   1        ncs = 1;
C51 COMPILER V9.53.0.0   SDCARD                                                            12/14/2015 14:47:00 PAGE 10  

 552   1        
 553   1        return error_flag;
 554   1        
 555   1      }
 556          
 557          
 558          
 559          
 560          
 561          uint8_t read_sector_ISR(uint32_t block_number, uint8_t *block_info)
 562          {
 563   1        uint8_t error_flag, timeout;
 564   1        uint8_t return_value[5];
 565   1        ncs = 0;
 566   1        timeout = 0;
 567   1        error_flag = send_command_ISR(17, block_number);
 568   1        do
 569   1        {
 570   2          timeout++;
 571   2          if(error_flag == NO_ERRORS)
 572   2            error_flag = get_response_no_end_ISR(1, &return_value);
 573   2        }while(return_value[0] != 0x00 && timeout != 0);
 574   1      
 575   1      
 576   1        if(timeout == 0)
 577   1        {
 578   2          error_flag = TIMEOUT_ERROR;
 579   2        }
 580   1        timeout = 0;
 581   1        do
 582   1        {
 583   2          timeout++;
 584   2          if(error_flag == NO_ERRORS)
 585   2            error_flag = get_response_no_end_ISR(1, &return_value);
 586   2        }while(return_value[0] != 0xFE    && timeout != 0 && error_flag == NO_ERRORS);
 587   1        
 588   1      
 589   1        
 590   1        if(timeout == 0)
 591   1        {
 592   2          error_flag = TIMEOUT_ERROR;
 593   2        }
 594   1        if((return_value[0] & 0xF0 )== 0x00)
 595   1        {
 596   2          error_flag = SDCARD_ERROR;
 597   2        }
 598   1        if(error_flag == NO_ERRORS)
 599   1        {
 600   2          error_flag = get_response_no_end_ISR(512, block_info);
 601   2        }
 602   1        if(error_flag == NO_ERRORS)
 603   1        {
 604   2          error_flag = get_response_no_end_ISR(3, &return_value);
 605   2      //    CRC16 = return_value[0] * 256 + return_value[1]; Check sum, dont care
 606   2        }
 607   1        ncs = 1;
 608   1        
 609   1        return error_flag;
 610   1        
 611   1      }
 612          
 613          
C51 COMPILER V9.53.0.0   SDCARD                                                            12/14/2015 14:47:00 PAGE 11  

 614          
 615          
 616          
 617          
 618          
 619          
 620          
 621          
 622          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1855    ----
   CONSTANT SIZE    =      8    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----     108
   IDATA SIZE       =   ----      16
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
