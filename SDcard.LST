C51 COMPILER V9.53.0.0   SDCARD                                                            11/06/2015 14:54:31 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE SDCARD
OBJECT MODULE PLACED IN SDcard.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE SDcard.c OPTIMIZE(8,SPEED) DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          #include "main.h"
   2          #include "port.h"
   3          #include "SDcard.h"
   4          #include "spi.h"
   5          #include "lcd.h"
   6          #include "hardware_delay.h"
   7          #include "print_bytes.h"
   8          #include <stdio.h>
   9          
  10          
  11          uint8_t SDcard_init()
  12          {
  13   1        uint8_t return_value[5];
  14   1        uint8_t error_flag, index, dat;
  15   1        
  16   1        AUXR = 0x0C;
  17   1        //Buffer ?
  18   1        ncs = 1;
  19   1        for(index = 0; index < 10; index++)
  20   1        {
  21   2          SPI_transfer(0xFF, return_value);
  22   2        }
  23   1        
  24   1        
  25   1        // Send CMD0 //
  26   1        
  27   1        error_flag = trans_CMD0(return_value);
  28   1        
  29   1        
  30   1        for (index=0;index<5;index++)
  31   1          {
  32   2             dat=return_value[index];
  33   2             printf("%2.2bX ",dat);
  34   2          }
  35   1        putchar(10);
  36   1        putchar(13);
  37   1        delay_ms(100);
  38   1        
  39   1      
  40   1      
  41   1        // Send CMD8 //
  42   1        if(error_flag == NO_ERRORS)
  43   1        {
  44   2          error_flag = trans_CMD8(return_value);
  45   2        }
  46   1        
  47   1      
  48   1      
  49   1        for (index=0;index<5;index++)
  50   1          {
  51   2             dat=return_value[index];
  52   2             printf("%2.2bX ",dat);
  53   2          }
  54   1        putchar(10);
  55   1        putchar(13);
C51 COMPILER V9.53.0.0   SDCARD                                                            11/06/2015 14:54:31 PAGE 2   

  56   1        delay_ms(100);
  57   1      
  58   1        // Send CMD58 //
  59   1        if(error_flag == NO_ERRORS)
  60   1        {
  61   2          error_flag = trans_CMD58(return_value);
  62   2          if(return_value[0] != 0x01)
  63   2          {
  64   3            error_flag = WRONG_RESPONSE;
  65   3            LED2 = 0;
  66   3          }
  67   2        }
  68   1        
  69   1      
  70   1      
  71   1        for (index=0;index<5;index++)
  72   1          {
  73   2             dat=return_value[index];
  74   2             printf("%2.2bX ",dat);
  75   2          }
  76   1        putchar(10);
  77   1        putchar(13);
  78   1        delay_ms(100);
  79   1      
  80   1        // Send ACMD41 //
  81   1        if(error_flag == NO_ERRORS)
  82   1        {
  83   2          error_flag = trans_ACMD41(return_value);
  84   2        }
  85   1      
  86   1      
  87   1      
  88   1        for (index=0;index<5;index++)
  89   1          {
  90   2             dat=return_value[index];
  91   2             printf("%2.2bX ",dat);
  92   2          }
  93   1        putchar(10);
  94   1        putchar(13);
  95   1        delay_ms(100);
  96   1        
  97   1        // Send CMD58 //
  98   1        if(error_flag == NO_ERRORS)
  99   1        {
 100   2          error_flag = trans_CMD58(return_value);
 101   2          if(return_value[1] & 0xC0) //bit 31 and 30 are set
 102   2          {
 103   3            //High Capacity
 104   3          }
 105   2          else if(return_value[1] & 0x80) // only bit 31 is set
 106   2          {
 107   3            //Standard Capacity
 108   3            error_flag = WRONG_SDCARD;
 109   3          }
 110   2          else
 111   2          {
 112   3            error_flag = WRONG_RESPONSE;
 113   3          }
 114   2        }
 115   1      
 116   1      
 117   1        for (index=0;index<5;index++)
C51 COMPILER V9.53.0.0   SDCARD                                                            11/06/2015 14:54:31 PAGE 3   

 118   1          {
 119   2             dat=return_value[index];
 120   2             printf("%2.2bX ",dat);
 121   2          }
 122   1        putchar(10);
 123   1        putchar(13);
 124   1        delay_ms(100);
 125   1        
 126   1        if(error_flag != NO_ERRORS) // LED4 is the error light and this should also be redundent.
 127   1        {
 128   2          LED4 = 0;
 129   2        }
 130   1        ncs = 1; // should not be needed but just in case
 131   1        
 132   1        return error_flag; 
 133   1      }
 134          
 135          
 136          
 137          
 138          
 139          
 140          
 141          
 142          
 143          
 144          
 145          
 146          
 147          
 148          
 149          
 150          uint8_t trans_CMD0(uint8_t *return_value)
 151          {
 152   1        uint8_t error_flag;
 153   1      
 154   1        // Send CMD0
 155   1        ncs = 0;
 156   1        error_flag = send_command(0, 0);
 157   1        if(error_flag == NO_ERRORS)
 158   1        {
 159   2          error_flag = get_response(1, return_value);
 160   2        }
 161   1        if(error_flag == NO_ERRORS)
 162   1        {
 163   2          if(return_value[0] != 0x01)
 164   2          {
 165   3            error_flag = WRONG_RESPONSE;
 166   3          }
 167   2        }
 168   1        ncs = 1;
 169   1        
 170   1        return error_flag;
 171   1      }
 172          
 173          
 174          
 175          
 176          
 177          uint8_t trans_CMD8(uint8_t *return_value)
 178          {
 179   1        uint8_t error_flag;
C51 COMPILER V9.53.0.0   SDCARD                                                            11/06/2015 14:54:31 PAGE 4   

 180   1        // Send CMD8
 181   1        ncs = 0;
 182   1        error_flag = send_command(8, 0x000001AA);
 183   1        if(error_flag == NO_ERRORS)
 184   1        {
 185   2          error_flag = get_response(5, return_value);
 186   2        }
 187   1        if(return_value[0] == 0x05)
 188   1          error_flag = VERSION_1_SD;
 189   1        else if(return_value[0] != 0x01)
 190   1          error_flag = FAIL_SDINIT;
 191   1        ncs = 1;
 192   1        return error_flag;
 193   1      }
 194          
 195          
 196          
 197          
 198          
 199          uint8_t trans_CMD58(uint8_t *return_value)
 200          {
 201   1        uint8_t error_flag;
 202   1        // SEND CMD58
 203   1        ncs = 0;
 204   1        error_flag = send_command(58, 0);
 205   1        if(error_flag == NO_ERRORS)
 206   1        {
 207   2          error_flag = get_response(5, return_value);
 208   2        }
 209   1      //  voltage_range = return_value[2];
 210   1        return error_flag;
 211   1      }
 212          
 213          
 214          
 215          
 216          uint8_t trans_ACMD41(uint8_t *return_value)
 217          {
 218   1        uint8_t error_flag, timeout;
 219   1        uint32_t ACMD41_argum = 0x40000000;
 220   1      
 221   1        
 222   1        // Send ACMD41
 223   1        
 224   1        ncs = 0;
 225   1        
 226   1      
 227   1        timeout = 0;
 228   1        do
 229   1        {
 230   2          timeout++;
 231   2          error_flag = send_command(55, 0);
 232   2          if(error_flag == NO_ERRORS)
 233   2            error_flag = get_response(1, return_value);
 234   2          if(!(return_value[0] == 0x00 || return_value[0] == 0x01))
 235   2            error_flag = SPI_ERROR;
 236   2          if(error_flag == NO_ERRORS)
 237   2            error_flag = send_command(41, ACMD41_argum);
 238   2          if(error_flag == NO_ERRORS)
 239   2            error_flag = get_response(1, return_value);
 240   2          if(!(return_value[0] == 0x00 || return_value[0] == 0x01))
 241   2            error_flag = SPI_ERROR;
C51 COMPILER V9.53.0.0   SDCARD                                                            11/06/2015 14:54:31 PAGE 5   

 242   2          timeout++;
 243   2        }while(return_value[0] != 0x00 && timeout != 0 && error_flag == NO_ERRORS);
 244   1        if(timeout == 0)
 245   1        {
 246   2          error_flag = TIMEOUT_ERROR;
 247   2        }
 248   1        ncs = 1;
 249   1        
 250   1        return error_flag;
 251   1      }
 252          
 253          
 254          
 255          
 256          
 257          
 258          
 259          
 260          
 261          uint8_t send_command(uint8_t cmd, uint32_t argum)
 262          {
 263   1        uint8_t error_flag, send_val, return_val, index;
 264   1        if(cmd < 64)
 265   1        {
 266   2          send_val = 0x40 | cmd;
 267   2          error_flag = SPI_transfer(send_val, &return_val);
 268   2          index = 24;
 269   2          while((error_flag == NO_ERRORS)&(index<25))
 270   2          {
 271   3            send_val = (uint8_t)(argum >> index);
 272   3            error_flag = SPI_transfer(send_val, &return_val);
 273   3            index -= 8;
 274   3          }
 275   2          if(cmd == 0)
 276   2            send_val = 0x95;
 277   2          else if(cmd == 8)
 278   2            send_val = 0x87;
 279   2          else
 280   2            send_val = 0x01;
 281   2          if(error_flag == NO_ERRORS)
 282   2            error_flag = SPI_transfer(send_val, &return_val);
 283   2          if(error_flag != NO_ERRORS)
 284   2            error_flag = SPI_ERROR;
 285   2        }
 286   1        else
 287   1          error_flag = ILLEGAL_COMMAND;
 288   1        return error_flag;
 289   1      }
 290          
 291          
 292          
 293          
 294          
 295          
 296          uint8_t get_response(uint8_t num_bytes, uint8_t *array_out)
 297          {
 298   1        uint8_t timeout, error_flag, recieve_value;
 299   1        uint8_t index;
 300   1        timeout = 0;
 301   1        error_flag = NO_ERRORS;
 302   1        do
 303   1        {
C51 COMPILER V9.53.0.0   SDCARD                                                            11/06/2015 14:54:31 PAGE 6   

 304   2          error_flag = SPI_transfer(0xFF, &recieve_value);
 305   2          timeout++;
 306   2        }while((timeout!=0)&&(error_flag == NO_ERRORS)&&(recieve_value == 0xFF));
 307   1        *array_out = recieve_value;
 308   1        if(timeout == 0)
 309   1          error_flag = TIMEOUT_ERROR;
 310   1        else if(error_flag != NO_ERRORS)
 311   1          error_flag = SPI_ERROR;
 312   1        else if((recieve_value != 0x01)&&(recieve_value != 0x00))
 313   1          error_flag = SPI_ERROR;
 314   1        else if(num_bytes > 1)
 315   1        {
 316   2          for(index = 1; index < num_bytes; index++)
 317   2          {
 318   3            SPI_transfer(0xFF, &recieve_value);
 319   3            *(array_out+index) = recieve_value;
 320   3          }
 321   2        }
 322   1        if(error_flag == NO_ERRORS)
 323   1          error_flag = SPI_transfer(0xFF, &recieve_value);
 324   1        return error_flag;
 325   1      }
 326          
 327          
 328          
 329          
 330          
 331          uint8_t get_response_no_end(uint16_t num_bytes, uint8_t *array_out)
 332          {
 333   1        uint8_t timeout, error_flag, recieve_value;
 334   1        uint16_t index;
 335   1        timeout = 0;
 336   1        error_flag = NO_ERRORS;
 337   1        for(index = 0; index < num_bytes; index++)
 338   1        {
 339   2          SPI_transfer(0xFF, &recieve_value);
 340   2          array_out[index] = recieve_value;
 341   2        }
 342   1        return error_flag;
 343   1      }
 344          
 345          
 346          
 347          
 348          
 349          
 350          
 351          uint8_t read_block(uint32_t block_number, uint8_t *block_info)
 352          {
 353   1        uint8_t error_flag, timeout;
 354   1        uint8_t return_value[5];
 355   1        ncs = 0;
 356   1        timeout = 0;
 357   1        //printf("%lu ",block_number);
 358   1        error_flag = send_command(17, block_number);
 359   1        do
 360   1        {
 361   2          timeout++;
 362   2          if(error_flag == NO_ERRORS)
 363   2            error_flag = get_response_no_end(1, &return_value);
 364   2        }while(return_value[0] != 0x00 && timeout != 0);
 365   1      
C51 COMPILER V9.53.0.0   SDCARD                                                            11/06/2015 14:54:31 PAGE 7   

 366   1      
 367   1        if(timeout == 0)
 368   1        {
 369   2          error_flag = TIMEOUT_ERROR;
 370   2        }
 371   1        timeout = 0;
 372   1        do
 373   1        {
 374   2          timeout++;
 375   2          if(error_flag == NO_ERRORS)
 376   2            error_flag = get_response_no_end(1, &return_value);
 377   2        }while(return_value[0] != 0xFE    && timeout != 0 && error_flag == NO_ERRORS);          //&& (return_value[0
             -] & 0xF0) != 0x00
 378   1        
 379   1      
 380   1        
 381   1        if(timeout == 0)
 382   1        {
 383   2          error_flag = TIMEOUT_ERROR;
 384   2        }
 385   1        if((return_value[0] & 0xF0 )== 0x00)
 386   1        {
 387   2          error_flag = SDCARD_ERROR;
 388   2        }
 389   1        if(error_flag == NO_ERRORS)
 390   1        {
 391   2          error_flag = get_response_no_end(512, block_info);
 392   2        }
 393   1        if(error_flag == NO_ERRORS)
 394   1        {
 395   2          error_flag = get_response_no_end(3, &return_value);
 396   2      //    CRC16 = return_value[0] * 256 + return_value[1]; Check sum, dont care
 397   2        }
 398   1        ncs = 1;
 399   1        
 400   1        return error_flag;
 401   1        
 402   1      }
 403          
 404          
 405          
 406          
 407          
 408          
 409          
 410          
 411          
 412          
 413          
 414          
 415          
 416          
 417          
 418          
 419          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1163    ----
   CONSTANT SIZE    =      8    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
C51 COMPILER V9.53.0.0   SDCARD                                                            11/06/2015 14:54:31 PAGE 8   

   DATA SIZE        =   ----      65
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
