C51 COMPILER V9.54   SDCARD                                                                11/07/2015 12:54:26 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE SDCARD
OBJECT MODULE PLACED IN SDcard.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE SDcard.c OPTIMIZE(8,SPEED) DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          #include "main.h"
   2          #include "port.h"
   3          #include "SDcard.h"
   4          #include "spi.h"
   5          #include "lcd.h"
   6          #include "hardware_delay.h"
   7          #include "print_bytes.h"
   8          #include <stdio.h>
   9          
  10          
  11          uint8_t SDcard_init()
  12          {
  13   1        uint8_t return_value[5];
  14   1        uint8_t error_flag, index, dat;
  15   1        
  16   1        AUXR = 0x0C;
  17   1        //Buffer ?
  18   1        ncs = 1;
  19   1        for(index = 0; index < 10; index++)
  20   1        {
  21   2          SPI_transfer(0xFF, return_value);
  22   2        }
  23   1        
  24   1        
  25   1        // Send CMD0 //
  26   1        
  27   1        error_flag = trans_CMD0(return_value);
  28   1        
  29   1        
  30   1        for (index=0;index<5;index++)
  31   1          {
  32   2             dat=return_value[index];
  33   2             printf("%2.2bX ",dat);
  34   2          }
  35   1        putchar(10);
  36   1        putchar(13);
  37   1        delay_ms(100);
  38   1        
  39   1      
  40   1      
  41   1        // Send CMD8 //
  42   1        if(error_flag == NO_ERRORS)
  43   1        {
  44   2          error_flag = trans_CMD8(return_value);
  45   2        }
  46   1        
  47   1      
  48   1      
  49   1        for (index=0;index<5;index++)
  50   1          {
  51   2             dat=return_value[index];
  52   2             printf("%2.2bX ",dat);
  53   2          }
  54   1        putchar(10);
  55   1        putchar(13);
C51 COMPILER V9.54   SDCARD                                                                11/07/2015 12:54:26 PAGE 2   

  56   1        delay_ms(100);
  57   1      
  58   1        // Send CMD58 //
  59   1        if(error_flag == NO_ERRORS)
  60   1        {
  61   2          error_flag = trans_CMD58(return_value);
  62   2          if(return_value[0] != 0x01)
  63   2          {
  64   3            error_flag = WRONG_RESPONSE;
  65   3            LED2 = 0;
  66   3          }
  67   2        }
  68   1        
  69   1      
  70   1      
  71   1        for (index=0;index<5;index++)
  72   1          {
  73   2             dat=return_value[index];
  74   2             printf("%2.2bX ",dat);
  75   2          }
  76   1        putchar(10);
  77   1        putchar(13);
  78   1        delay_ms(100);
  79   1      
  80   1        // Send ACMD41 //
  81   1        if(error_flag == NO_ERRORS)
  82   1        {
  83   2          error_flag = trans_ACMD41(return_value);
  84   2        }
  85   1      
  86   1      
  87   1      
  88   1        for (index=0;index<5;index++)
  89   1          {
  90   2             dat=return_value[index];
  91   2             printf("%2.2bX ",dat);
  92   2          }
  93   1        putchar(10);
  94   1        putchar(13);
  95   1        delay_ms(100);
  96   1        
  97   1        // Send CMD58 //
  98   1        if(error_flag == NO_ERRORS)
  99   1        {
 100   2          error_flag = trans_CMD58(return_value);
 101   2          if(return_value[1] & 0xC0) //bit 31 and 30 are set
 102   2          {
 103   3            //High Capacity
 104   3          }
 105   2          else if(return_value[1] & 0x80) // only bit 31 is set
 106   2          {
 107   3            //Standard Capacity
 108   3            error_flag = WRONG_SDCARD;
 109   3          }
 110   2          else
 111   2          {
 112   3            error_flag = WRONG_RESPONSE;
 113   3          }
 114   2        }
 115   1      
 116   1      
 117   1        for (index=0;index<5;index++)
C51 COMPILER V9.54   SDCARD                                                                11/07/2015 12:54:26 PAGE 3   

 118   1          {
 119   2             dat=return_value[index];
 120   2             printf("%2.2bX ",dat);
 121   2          }
 122   1        putchar(10);
 123   1        putchar(13);
 124   1        delay_ms(100);
 125   1        
 126   1        if(error_flag != NO_ERRORS) // LED4 is the error light and this should also be redundent.
 127   1        {
 128   2          LED4 = 0;
 129   2        }
 130   1        ncs = 1; // should not be needed but just in case
 131   1        
 132   1        return error_flag; 
 133   1      }
 134          
 135          
 136          
 137          
 138          
 139          
 140          
 141          
 142          
 143          
 144          
 145          
 146          
 147          
 148          
 149          
 150          uint8_t trans_CMD0(uint8_t *return_value)
 151          {
 152   1        uint8_t error_flag;
 153   1      
 154   1        // Send CMD0
 155   1        ncs = 0;
 156   1        error_flag = send_command(0, 0);
 157   1        if(error_flag == NO_ERRORS)
 158   1        {
 159   2          error_flag = get_response(1, return_value);
 160   2        }
 161   1        if(error_flag == NO_ERRORS)
 162   1        {
 163   2          if(return_value[0] != 0x01)
 164   2          {
 165   3            error_flag = WRONG_RESPONSE;
 166   3          }
 167   2        }
 168   1        ncs = 1;
 169   1        
 170   1        return error_flag;
 171   1      }
 172          
 173          
 174          
 175          
 176          
 177          uint8_t trans_CMD8(uint8_t *return_value)
 178          {
 179   1        uint8_t error_flag;
C51 COMPILER V9.54   SDCARD                                                                11/07/2015 12:54:26 PAGE 4   

 180   1        // Send CMD8
 181   1        ncs = 0;
 182   1        error_flag = send_command(8, 0x000001AA);
 183   1        if(error_flag == NO_ERRORS)
 184   1        {
 185   2          error_flag = get_response(5, return_value);
 186   2        }
 187   1        if(return_value[0] == 0x05)
 188   1          error_flag = VERSION_1_SD;
 189   1        else if(return_value[0] != 0x01)
 190   1          error_flag = FAIL_SDINIT;
 191   1        ncs = 1;
 192   1        return error_flag;
 193   1      }
 194          
 195          
 196          
 197          
 198          
 199          uint8_t trans_CMD58(uint8_t *return_value)
 200          {
 201   1        uint8_t error_flag;
 202   1        // SEND CMD58
 203   1        ncs = 0;
 204   1        error_flag = send_command(58, 0);
 205   1        if(error_flag == NO_ERRORS)
 206   1        {
 207   2          error_flag = get_response(5, return_value);
 208   2        }
 209   1        return error_flag;
 210   1      }
 211          
 212          
 213          
 214          
 215          uint8_t trans_ACMD41(uint8_t *return_value)
 216          {
 217   1        uint8_t error_flag, timeout;
 218   1        uint32_t ACMD41_argum = 0x40000000;
 219   1      
 220   1        
 221   1        // Send ACMD41
 222   1        
 223   1        ncs = 0;
 224   1        
 225   1      
 226   1        timeout = 0;
 227   1        do
 228   1        {
 229   2          timeout++;
 230   2          error_flag = send_command(55, 0);
 231   2          if(error_flag == NO_ERRORS)
 232   2            error_flag = get_response(1, return_value);
 233   2          if(!(return_value[0] == 0x00 || return_value[0] == 0x01))
 234   2            error_flag = SPI_ERROR;
 235   2          if(error_flag == NO_ERRORS)
 236   2            error_flag = send_command(41, ACMD41_argum);
 237   2          if(error_flag == NO_ERRORS)
 238   2            error_flag = get_response(1, return_value);
 239   2          if(!(return_value[0] == 0x00 || return_value[0] == 0x01))
 240   2            error_flag = SPI_ERROR;
 241   2          timeout++;
C51 COMPILER V9.54   SDCARD                                                                11/07/2015 12:54:26 PAGE 5   

 242   2        }while(return_value[0] != 0x00 && timeout != 0 && error_flag == NO_ERRORS);
 243   1        if(timeout == 0)
 244   1        {
 245   2          error_flag = TIMEOUT_ERROR;
 246   2        }
 247   1        ncs = 1;
 248   1        
 249   1        return error_flag;
 250   1      }
 251          
 252          
 253          
 254          
 255          
 256          
 257          
 258          
 259          
 260          uint8_t send_command(uint8_t cmd, uint32_t argum)
 261          {
 262   1        uint8_t error_flag, send_val, return_val, index;
 263   1        if(cmd < 64)
 264   1        {
 265   2          send_val = 0x40 | cmd;
 266   2          error_flag = SPI_transfer(send_val, &return_val);
 267   2          index = 24;
 268   2          while((error_flag == NO_ERRORS)&(index<25))
 269   2          {
 270   3            send_val = (uint8_t)(argum >> index);
 271   3            error_flag = SPI_transfer(send_val, &return_val);
 272   3            index -= 8;
 273   3          }
 274   2          if(cmd == 0)
 275   2            send_val = 0x95;
 276   2          else if(cmd == 8)
 277   2            send_val = 0x87;
 278   2          else
 279   2            send_val = 0x01;
 280   2          if(error_flag == NO_ERRORS)
 281   2            error_flag = SPI_transfer(send_val, &return_val);
 282   2          if(error_flag != NO_ERRORS)
 283   2            error_flag = SPI_ERROR;
 284   2        }
 285   1        else
 286   1          error_flag = ILLEGAL_COMMAND;
 287   1        return error_flag;
 288   1      }
 289          
 290          
 291          
 292          
 293          
 294          
 295          uint8_t get_response(uint8_t num_bytes, uint8_t *array_out)
 296          {
 297   1        uint8_t timeout, error_flag, recieve_value;
 298   1        uint8_t index;
 299   1        timeout = 0;
 300   1        error_flag = NO_ERRORS;
 301   1        do
 302   1        {
 303   2          error_flag = SPI_transfer(0xFF, &recieve_value);
C51 COMPILER V9.54   SDCARD                                                                11/07/2015 12:54:26 PAGE 6   

 304   2          timeout++;
 305   2        }while((timeout!=0)&&(error_flag == NO_ERRORS)&&(recieve_value == 0xFF));
 306   1        *array_out = recieve_value;
 307   1        if(timeout == 0)
 308   1          error_flag = TIMEOUT_ERROR;
 309   1        else if(error_flag != NO_ERRORS)
 310   1          error_flag = SPI_ERROR;
 311   1        else if((recieve_value != 0x01)&&(recieve_value != 0x00))
 312   1          error_flag = SPI_ERROR;
 313   1        else if(num_bytes > 1)
 314   1        {
 315   2          for(index = 1; index < num_bytes; index++)
 316   2          {
 317   3            SPI_transfer(0xFF, &recieve_value);
 318   3            *(array_out+index) = recieve_value;
 319   3          }
 320   2        }
 321   1        if(error_flag == NO_ERRORS)
 322   1          error_flag = SPI_transfer(0xFF, &recieve_value);
 323   1        return error_flag;
 324   1      }
 325          
 326          
 327          
 328          
 329          
 330          uint8_t get_response_no_end(uint16_t num_bytes, uint8_t *array_out)
 331          {
 332   1        uint8_t timeout, error_flag, recieve_value;
 333   1        uint16_t index;
 334   1        timeout = 0;
 335   1        error_flag = NO_ERRORS;
 336   1        for(index = 0; index < num_bytes; index++)
 337   1        {
 338   2          SPI_transfer(0xFF, &recieve_value);
 339   2          array_out[index] = recieve_value;
 340   2        }
 341   1        return error_flag;
 342   1      }
 343          
 344          
 345          
 346          
 347          
 348          
 349          
 350          uint8_t read_block(uint32_t block_number, uint8_t *block_info)
 351          {
 352   1        uint8_t error_flag, timeout;
 353   1        uint8_t return_value[5];
 354   1        ncs = 0;
 355   1        timeout = 0;
 356   1        error_flag = send_command(17, block_number);
 357   1        do
 358   1        {
 359   2          timeout++;
 360   2          if(error_flag == NO_ERRORS)
 361   2            error_flag = get_response_no_end(1, &return_value);
 362   2        }while(return_value[0] != 0x00 && timeout != 0);
 363   1      
 364   1      
 365   1        if(timeout == 0)
C51 COMPILER V9.54   SDCARD                                                                11/07/2015 12:54:26 PAGE 7   

 366   1        {
 367   2          error_flag = TIMEOUT_ERROR;
 368   2        }
 369   1        timeout = 0;
 370   1        do
 371   1        {
 372   2          timeout++;
 373   2          if(error_flag == NO_ERRORS)
 374   2            error_flag = get_response_no_end(1, &return_value);
 375   2        }while(return_value[0] != 0xFE    && timeout != 0 && error_flag == NO_ERRORS);
 376   1        
 377   1      
 378   1        
 379   1        if(timeout == 0)
 380   1        {
 381   2          error_flag = TIMEOUT_ERROR;
 382   2        }
 383   1        if((return_value[0] & 0xF0 )== 0x00)
 384   1        {
 385   2          error_flag = SDCARD_ERROR;
 386   2        }
 387   1        if(error_flag == NO_ERRORS)
 388   1        {
 389   2          error_flag = get_response_no_end(512, block_info);
 390   2        }
 391   1        if(error_flag == NO_ERRORS)
 392   1        {
 393   2          error_flag = get_response_no_end(3, &return_value);
 394   2      //    CRC16 = return_value[0] * 256 + return_value[1]; Check sum, dont care
 395   2        }
 396   1        ncs = 1;
 397   1        
 398   1        return error_flag;
 399   1        
 400   1      }
 401          
 402          
 403          
 404          
 405          
 406          
 407          
 408          
 409          
 410          
 411          
 412          
 413          
 414          
 415          
 416          
 417          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1163    ----
   CONSTANT SIZE    =      8    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      65
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
C51 COMPILER V9.54   SDCARD                                                                11/07/2015 12:54:26 PAGE 8   

END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
